var Lo = Object.defineProperty, Ao = Object.defineProperties;
var Zo = Object.getOwnPropertyDescriptors;
var an = Object.getOwnPropertySymbols;
var Do = Object.prototype.hasOwnProperty, No = Object.prototype.propertyIsEnumerable;
var ae = Math.pow, ln = (e, t, n) => t in e ? Lo(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, se = (e, t) => {
  for (var n in t || (t = {}))
    Do.call(t, n) && ln(e, n, t[n]);
  if (an)
    for (var n of an(t))
      No.call(t, n) && ln(e, n, t[n]);
  return e;
}, qe = (e, t) => Ao(e, Zo(t));
var Ee = (e, t, n) => new Promise((o, i) => {
  var s = (l) => {
    try {
      a(n.next(l));
    } catch (u) {
      i(u);
    }
  }, r = (l) => {
    try {
      a(n.throw(l));
    } catch (u) {
      i(u);
    }
  }, a = (l) => l.done ? o(l.value) : Promise.resolve(l.value).then(s, r);
  a((n = n.apply(e, t)).next());
});
import { isReactive as jo, reactive as Oe, provide as Ze, inject as De, watch as U, toRef as Ce, watchEffect as me, computed as C, unref as b, ref as j, onMounted as Ue, onUnmounted as tt, nextTick as jt, defineComponent as _, openBlock as M, createElementBlock as L, createBlock as H, resolveDynamicComponent as On, createCommentVNode as ce, Fragment as G, renderList as J, mergeProps as Pe, renderSlot as K, normalizeClass as ve, withModifiers as xe, normalizeStyle as nt, useAttrs as Bo, createElementVNode as zn, createTextVNode as Ro, toDisplayString as cn, createVNode as Re, withCtx as ne, normalizeProps as ue, guardReactiveProps as de, useSlots as vt, createSlots as Bt, TransitionGroup as Je, toHandlers as Vo, readonly as Ge } from "vue";
import { isEqual as $e, round as un, merge as Tn, mergeWith as Wo, isPlainObject as Ho, debounce as _o, uniq as Fo, chunk as Rt } from "lodash-es";
const Uo = [
  "paths",
  "node-labels",
  "nodes",
  "focusring",
  "edge-labels",
  "edges",
  "base",
  "grid",
  "background",
  "root"
];
function Ie(e) {
  return jo(e) ? e : Oe(e);
}
function q(e, t = "Parameter") {
  if (e == null)
    throw new Error(`${t} is null`);
  return e;
}
const In = Symbol("containers");
function Xo(e) {
  Ze(In, e);
}
function Vt() {
  const e = q(De(In), "containers");
  return {
    container: e.container,
    svg: e.svg,
    viewport: e.viewport,
    svgPanZoom: e.svgPanZoom
  };
}
class $ {
  static value(t, n) {
    return t instanceof Function ? t(n) : t;
  }
  static values(t, n) {
    return Object.values(t).filter((o) => o instanceof Function).length === 0 ? t : Object.fromEntries(
      Object.entries(t).map(([o, i]) => [o, i instanceof Function ? i(n) : i])
    );
  }
}
var N = /* @__PURE__ */ ((e) => (e.CENTER = "center", e.NORTH = "north", e.NORTH_EAST = "north-east", e.EAST = "east", e.SOUTH_EAST = "south-east", e.SOUTH = "south", e.SOUTH_WEST = "south-west", e.WEST = "west", e.NORTH_WEST = "north-west", e))(N || {});
function Ct(e) {
  const t = {};
  return Object.assign(t, e(t));
}
function Qr(e) {
  return e;
}
function Jr(e) {
  return e;
}
function dn(e, t, n) {
  const o = $.values(t.normal, e);
  return o.type == "circle" ? {
    width: o.radius * 2 * n,
    height: o.radius * 2 * n
  } : {
    width: o.width * n,
    height: o.height * n
  };
}
function qo(e, t, n, o) {
  const s = Math.abs(e.x - n.x) < t.width / 2 + o.width / 2, a = Math.abs(e.y - n.y) < t.height / 2 + o.height / 2;
  return s && a;
}
function ot(e, t) {
  let n = 0;
  return t === 1 || e === void 0 || e === "none" ? n = e != null ? e : 0 : typeof e == "string" ? n = e.split(/\s+/).map((o) => parseInt(o) * t).filter((o) => !isNaN(o)).join(" ") : n = e * t, n && n !== "0" ? n : void 0;
}
function gt(e) {
  let t = 0;
  if (e === void 0 || e === "none")
    t = 0;
  else if (typeof e == "string") {
    const n = e.split(/\s+/).map((o) => parseInt(o)).filter((o) => !isNaN(o));
    n.length % 2 === 0 ? t = n.reduce((o, i) => o + i, 0) : t = n.reduce((o, i) => o + i, 0) * 2;
  } else
    t = e * 2;
  return t;
}
const fn = 20;
class $n {
  activate(t) {
    const { nodePositions: n, nodes: o, configs: i, emitter: s, scale: r, svgPanZoom: a } = t, l = (d) => {
      for (const [h, v] of Object.entries(d)) {
        const E = this.getOrCreateNodePosition(n, h);
        this.setNodePosition(E, v);
      }
    }, u = (d) => {
      const h = d.filter((x) => !(x in n.value)), v = a.getViewArea(), E = r.value;
      for (const x of h) {
        const w = o.value[x], g = dn(w, i.node, E), y = se({}, v.center);
        for (; ; ) {
          let m = !1;
          for (const [f, p] of Object.entries(n.value)) {
            if (x === f) continue;
            const S = o.value[f];
            if (!S) continue;
            const O = dn(S, i.node, E);
            if (m = qo(y, g, p, O), m)
              break;
          }
          if (m)
            y.x += g.width + fn * E, y.x + g.width / 2 > v.box.right && (y.x = v.center.x, y.y += g.height + fn * E);
          else
            break;
        }
        const k = this.getOrCreateNodePosition(n, x);
        this.setNodePosition(k, y);
      }
    };
    u(Object.keys(o.value));
    const c = U(
      () => $e(new Set(Object.keys(o.value)), new Set(Object.keys(n.value))),
      (d) => {
        d || u(Object.keys(o.value));
      }
    );
    s.on("node:dragstart", l), s.on("node:pointermove", l), s.on("node:dragend", l), this.onDeactivate = () => {
      c(), s.off("node:dragstart", l), s.off("node:pointermove", l), s.off("node:dragend", l);
    };
  }
  deactivate() {
    this.onDeactivate && this.onDeactivate();
  }
  setNodePosition(t, n) {
    t.value.x = un(n.x, 3), t.value.y = un(n.y, 3);
  }
  getOrCreateNodePosition(t, n) {
    const o = Ce(t.value, n);
    return o.value || (o.value = { x: 0, y: 0 }), o;
  }
}
function Ln() {
  return {
    view: {
      scalingObjects: !1,
      panEnabled: !0,
      zoomEnabled: !0,
      minZoomLevel: 0.1,
      maxZoomLevel: 64,
      doubleClickZoomEnabled: !0,
      mouseWheelZoomEnabled: !0,
      boxSelectionEnabled: !1,
      autoPanAndZoomOnLoad: "center-content",
      fitContentMargin: "8%",
      autoPanOnResize: !0,
      layoutHandler: new $n(),
      onSvgPanZoomInitialized: void 0,
      grid: {
        visible: !1,
        interval: 10,
        thickIncrements: 5,
        line: {
          color: "#e0e0e0",
          width: 1,
          dasharray: 1
        },
        thick: {
          color: "#cccccc",
          width: 1,
          dasharray: 0
        }
      },
      selection: {
        box: {
          color: "#0000ff20",
          strokeWidth: 1,
          strokeColor: "#aaaaff",
          strokeDasharray: 0
        },
        detector: (e) => {
          const t = /Mac OS/.test(navigator.userAgent) ? e.metaKey : e.ctrlKey;
          return e.type === "keydown" ? t : !t;
        }
      },
      builtInLayerOrder: [],
      onBeforeInitialDisplay: void 0
    },
    node: Ct((e) => ({
      normal: {
        type: "circle",
        radius: 16,
        // for rect -->
        width: 32,
        height: 32,
        borderRadius: 4,
        // <-- for rect
        color: "#4466cc",
        strokeWidth: 0,
        strokeColor: "#000000",
        strokeDasharray: 0
      },
      hover: {
        type: (t) => $.value(e.normal.type, t),
        radius: (t) => {
          var n;
          return ((n = $.value(e.normal.radius, t)) != null ? n : 0) + 2;
        },
        width: (t) => {
          var n;
          return ((n = $.value(e.normal.width, t)) != null ? n : 0) + 2;
        },
        height: (t) => {
          var n;
          return ((n = $.value(e.normal.height, t)) != null ? n : 0) + 2;
        },
        borderRadius: (t) => {
          var n;
          return (n = $.value(e.normal.borderRadius, t)) != null ? n : 0;
        },
        strokeWidth: (t) => $.value(e.normal.strokeWidth, t),
        strokeColor: (t) => $.value(e.normal.strokeColor, t),
        strokeDasharray: (t) => $.value(e.normal.strokeDasharray, t),
        color: "#3355bb"
      },
      selected: void 0,
      draggable: !0,
      selectable: !1,
      label: {
        visible: !0,
        fontFamily: void 0,
        fontSize: 11,
        lineHeight: 1.1,
        color: "#000000",
        background: void 0,
        // background: {
        //   visible: true,
        //   color: "#ffffff",
        //   padding: {
        //     vertical: 1,
        //     horizontal: 4,
        //   },
        //   borderRadius: 2
        // },
        margin: 4,
        direction: N.SOUTH,
        directionAutoAdjustment: !1,
        text: "name",
        handleNodeEvents: !0
      },
      focusring: {
        visible: !0,
        width: 4,
        padding: 3,
        color: "#eebb00"
      },
      zOrder: {
        enabled: !1,
        zIndex: 0,
        bringToFrontOnHover: !0,
        bringToFrontOnSelected: !0
      },
      transition: void 0
    })),
    edge: Ct((e) => ({
      normal: {
        width: 2,
        color: "#4466cc",
        dasharray: 0,
        linecap: "butt",
        animate: !1,
        animationSpeed: 50
      },
      hover: {
        width: (t) => $.value(e.normal.width, t) + 1,
        color: "#3355bb",
        dasharray: (t) => $.value(e.normal.dasharray, t),
        linecap: (t) => $.value(e.normal.linecap, t),
        animate: (t) => $.value(e.normal.animate, t),
        animationSpeed: (t) => $.value(e.normal.animationSpeed, t)
      },
      selected: {
        width: (t) => $.value(e.normal.width, t) + 1,
        color: "#dd8800",
        dasharray: (t) => {
          const n = $.value(e.normal.width, t);
          return `${n * 1.5} ${n * 2}`;
        },
        linecap: (t) => $.value(e.normal.linecap, t),
        animate: (t) => $.value(e.normal.animate, t),
        animationSpeed: (t) => $.value(e.normal.animationSpeed, t)
      },
      selectable: !1,
      gap: 3,
      type: "straight",
      marker: {
        source: {
          type: "none",
          width: 5,
          height: 5,
          margin: -1,
          offset: 0,
          units: "strokeWidth",
          color: null
        },
        target: {
          type: "none",
          width: 5,
          height: 5,
          margin: -1,
          offset: 0,
          units: "strokeWidth",
          color: null
        }
      },
      margin: null,
      summarize: (t, n) => n.edge.type == "curve" ? !1 : null,
      summarized: {
        label: {
          fontSize: 10,
          lineHeight: 1,
          color: "#4466cc"
        },
        shape: {
          type: "rect",
          // for circle -->
          radius: 6,
          // <-- for circle
          width: 12,
          height: 12,
          borderRadius: 3,
          color: "#ffffff",
          strokeWidth: 1,
          strokeColor: "#4466cc",
          strokeDasharray: void 0
        },
        stroke: {
          width: 5,
          color: "#4466cc",
          dasharray: void 0,
          linecap: void 0,
          animate: !1,
          animationSpeed: 50
        }
      },
      selfLoop: {
        radius: 12,
        isClockwise: !0,
        offset: 10,
        angle: 270
      },
      keepOrder: "clock",
      label: {
        fontFamily: void 0,
        fontSize: 11,
        lineHeight: 1.1,
        color: "#000000",
        background: void 0,
        // background: {
        //   visible: true,
        //   color: "#ffffff",
        //   padding: {
        //     vertical: 1,
        //     horizontal: 4,
        //   },
        //   borderRadius: 2
        // },
        margin: 4,
        padding: 4
      },
      zOrder: {
        enabled: !1,
        zIndex: 0,
        bringToFrontOnHover: !0,
        bringToFrontOnSelected: !0
      }
    })),
    path: Ct((e) => ({
      visible: !1,
      clickable: !1,
      hoverable: !1,
      curveInNode: !1,
      end: "centerOfNode",
      margin: 0,
      // @Deprecated
      path: Oe({
        width: 6,
        color: (t) => {
          const n = [
            "#d5000088",
            "#c5116288",
            "#aa00ff88",
            "#6200ea88",
            "#304ffe88",
            "#2962ff88",
            "#0091ea88",
            "#00b8d488",
            "#00bfa588",
            "#00c85388",
            "#64dd1788",
            "#aeea0088",
            "#ffd60088",
            "#ffab0088",
            "#ff6d0088",
            "#dd2c0088"
          ], o = t.edges.map(
            (i) => i.split("").reduce((s, r) => (s = (s << 5) - s + r.charCodeAt(0), s & s), 0)
          ).reduce((i, s) => i + s, 0);
          return n[Math.abs(o) % n.length];
        },
        dasharray: void 0,
        linecap: "round",
        linejoin: "round",
        animate: !1,
        animationSpeed: 50
      }),
      normal: {
        width: (t) => $.value(e.path.width, t),
        color: (t) => $.value(e.path.color, t),
        dasharray: (t) => $.value(e.path.dasharray, t),
        linecap: (t) => $.value(e.path.linecap, t),
        linejoin: (t) => $.value(e.path.linejoin, t),
        animate: (t) => $.value(e.path.animate, t),
        animationSpeed: (t) => $.value(e.path.animationSpeed, t)
      },
      hover: {
        width: (t) => $.value(e.normal.width, t) + 2,
        color: (t) => $.value(e.normal.color, t),
        dasharray: (t) => $.value(e.normal.dasharray, t),
        linecap: (t) => $.value(e.normal.linecap, t),
        linejoin: (t) => $.value(e.normal.linejoin, t),
        animate: (t) => $.value(e.normal.animate, t),
        animationSpeed: (t) => $.value(e.normal.animationSpeed, t)
      },
      selected: {
        width: (t) => $.value(e.normal.width, t) + 2,
        color: (t) => $.value(e.normal.color, t),
        dasharray: "6 12",
        linecap: (t) => $.value(e.normal.linecap, t),
        linejoin: (t) => $.value(e.normal.linejoin, t),
        animate: (t) => $.value(e.normal.animate, t),
        animationSpeed: (t) => $.value(e.normal.animationSpeed, t)
      },
      selectable: !1,
      zOrder: {
        enabled: !1,
        zIndex: 0,
        bringToFrontOnHover: !0,
        bringToFrontOnSelected: !0
      },
      transition: void 0
    }))
  };
}
function ea(e) {
  const t = Ln();
  return e && Tn(t, e), t;
}
const An = Symbol("style");
function Go(e, t) {
  return Ho(e) ? Tn(e, t) : t;
}
function Ko(e) {
  const t = Oe(Ln()), n = Object.keys(t);
  for (const o of n)
    U(() => e.value[o], () => {
      Wo(t[o], e.value[o] || {}, Go);
    }, { immediate: !0, deep: !0 });
  return Ze(An, t), t;
}
function pt(e) {
  return q(De(An), `Configs(${e})`)[e];
}
function Yo() {
  return pt("view");
}
function mt() {
  return pt("node");
}
function bt() {
  return pt("edge");
}
function Zn() {
  return pt("path");
}
let Qo = 1;
function Jo() {
  return Qo++;
}
function he(e) {
  return Object.entries(e);
}
function lt(e, t) {
  const n = new Set(Object.keys(e));
  he(t).forEach(([o, i]) => {
    $e(e[o], i) || (e[o] = i), n.delete(o);
  }), n.forEach((o) => delete e[o]);
}
function ei(e) {
  return e instanceof Promise || e && typeof e.then == "function";
}
function ti(e, t, n) {
  const o = Ie({
    edgeLayoutPoints: {},
    edgeGroups: {},
    summarizedEdges: {}
  });
  return me(() => {
    const { edgeLayoutPoints: i, edgeGroups: s } = oi(
      n,
      e.value,
      t.value
    );
    lt(o.edgeLayoutPoints, i), lt(o.edgeGroups, s);
  }), me(() => {
    const i = {};
    for (const [s, { edges: r, groupWidth: a }] of Object.entries(o.edgeGroups)) {
      let l = !1;
      if (a == 0)
        l = !1;
      else if (n.edge.summarize instanceof Function) {
        const u = n.edge.summarize(r, n);
        u === null ? l = hn(e.value, r, n, a) : l = u;
      } else n.edge.summarize ? l = hn(e.value, r, n, a) : l = !1;
      o.edgeGroups[s].summarize = l, l && Object.keys(r).forEach((u) => i[u] = !0);
    }
    lt(o.summarizedEdges, i);
  }), o;
}
function ni(e, t, n, o, i, s) {
  return e ? t ? vn(e.edge, n, o, i, 0, 0, s) : vn(
    e.edge,
    n,
    o,
    i,
    e.groupWidth,
    e.pointInGroup,
    s
  ) : { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } };
}
function oi(e, t, n) {
  const o = {}, i = {}, s = {};
  for (const [a, l] of Object.entries(n)) {
    if (!(l.source in t && l.target in t))
      continue;
    const u = [l.source, l.target].sort().join("<=>"), c = s[u] || {};
    c[a] = l, s[u] = c;
  }
  const r = e.edge.gap instanceof Function ? e.edge.gap : (a, l) => e.edge.gap;
  for (const [a, l] of Object.entries(s)) {
    const u = Object.keys(l).length;
    if (u == 0) continue;
    const c = r(l, e), [d, h] = Object.entries(l)[0];
    if (u === 1)
      o[d] = { edge: h, pointInGroup: 0, groupWidth: 0 }, i[a] = { edges: l, groupWidth: 0, summarize: !1 };
    else {
      let v = 0;
      const E = Object.entries(l).map(([g, y]) => {
        let k = $.value(e.edge.normal.width, y);
        return isNaN(+k) && (console.warn(
          "[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]",
          g,
          k
        ), k = 1), k / 2;
      }), x = Object.entries(l).map(([g, y], k) => (k > 0 && (v += E[k - 1] + c + E[k]), [g, y, v])), w = v;
      x.forEach(([g, y, k]) => {
        o[g] = { edge: y, pointInGroup: k, groupWidth: w };
      }), i[a] = { edges: l, groupWidth: w, summarize: !1 };
    }
  }
  return { edgeLayoutPoints: o, edgeGroups: i };
}
function hn(e, t, n, o) {
  if (Object.entries(t).length === 1) return !1;
  const s = Math.min(
    ...Object.values(t).flatMap((r) => [e[r.source], e[r.target]]).filter((r) => r).map((r) => {
      const a = $.values(n.node.normal, r);
      return a.type === "circle" ? a.radius * 2 : Math.min(a.width, a.height);
    })
  );
  return o > s;
}
function vn(e, t, n, o, i, s, r) {
  var d, h, v, E, x, w, g, y;
  let a, l, u, c;
  return e.source < e.target ? [a, l, u, c] = gn(
    (d = t == null ? void 0 : t.x) != null ? d : 0,
    (h = t == null ? void 0 : t.y) != null ? h : 0,
    (v = n == null ? void 0 : n.x) != null ? v : 0,
    (E = n == null ? void 0 : n.y) != null ? E : 0,
    o,
    i,
    s,
    r
  ) : [u, c, a, l] = gn(
    (x = n == null ? void 0 : n.x) != null ? x : 0,
    (w = n == null ? void 0 : n.y) != null ? w : 0,
    (g = t == null ? void 0 : t.x) != null ? g : 0,
    (y = t == null ? void 0 : t.y) != null ? y : 0,
    o,
    i,
    s,
    r
  ), { p1: { x: a, y: l }, p2: { x: u, y: c } };
}
function gn(e, t, n, o, i, s, r, a) {
  const l = n - e, u = o - t;
  let c = (s / 2 - r) * i;
  if (c !== 0 && a !== "clock") {
    const d = Math.atan2(o - t, n - e);
    if (a === "vertical") {
      const h = Math.PI / 2;
      (d < -h || d >= h) && (c *= -1);
    } else a === "horizontal" && d < 0 && (c *= -1);
  }
  if (l === 0) {
    const d = u < 0 ? -1 : 1;
    return [e + c * d, t, n + c * d, o];
  } else if (u === 0) {
    const d = l < 0 ? 1 : -1;
    return [e, t + c * d, n, o + c * d];
  } else {
    const h = -1 / (u / l);
    u < 0 && (c = -c);
    const v = c / Math.sqrt(1 + Math.pow(h, 2));
    return [e + v, t + v * h, n + v, o + v * h];
  }
}
function Dn(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x + t.x, n.y = e.y + t.y, n;
}
function Wt(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x - t.x, n.y = e.y - t.y, n;
}
function Nn(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x * t.x, n.y = e.y * t.y, n;
}
function jn(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x * t, n.y = e.y * t, n;
}
function Ht(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x / t.x, n.y = e.y / t.y, n;
}
function Bn(e, t) {
  return e.x * t.x + e.y * t.y;
}
function Rn(e, t) {
  return e.x * t.y - e.y * t.x;
}
function _t(e) {
  return e.x * e.x + e.y * e.y;
}
function Ft(e) {
  return Math.sqrt(_t(e));
}
function Ut(e, t) {
  const n = e.x - t.x, o = e.y - t.y;
  return n * n + o * o;
}
function Vn(e, t) {
  return Math.sqrt(Ut(e, t));
}
function Wn(e, t) {
  t || (t = { x: 0, y: 0 });
  const n = Ft(e);
  return n === 0 ? (t.x = 1, t.y = 0) : Ht(e, { x: n, y: n }, t), t;
}
function ut(e, t, n) {
  n || (n = { x: 0, y: 0 });
  const o = e.x * Math.cos(t) - e.y * Math.sin(t), i = e.x * Math.sin(t) + e.y * Math.cos(t);
  return n.x = o, n.y = i, n;
}
const ii = 180 / Math.PI;
function si(e) {
  return e * ii;
}
function Xt(e) {
  return Math.atan2(e.y, e.x);
}
function qt(e) {
  return si(Xt(e));
}
const ri = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: Dn,
  angle: Xt,
  angleDegree: qt,
  cross: Rn,
  distance: Vn,
  distanceSquared: Ut,
  divide: Ht,
  dot: Bn,
  length: Ft,
  lengthSquared: _t,
  multiply: Nn,
  multiplyScalar: jn,
  normalize: Wn,
  rotate: ut,
  subtract: Wt
}, Symbol.toStringTag, { value: "Module" }));
class V {
  static fromArray(t) {
    return new V(t[0] || 0, t[1] || 0);
  }
  static fromObject(t) {
    return new V(t.x, t.y);
  }
  constructor(t, n) {
    this.x = t, this.y = n;
  }
  // instance methods
  add(t) {
    return Dn(this, t, this);
  }
  subtract(t) {
    return Wt(this, t, this);
  }
  multiply(t) {
    return Nn(this, t, this);
  }
  multiplyScalar(t) {
    return jn(this, t, this);
  }
  divide(t) {
    return Ht(this, t, this);
  }
  dot(t) {
    return Bn(this, t);
  }
  cross(t) {
    return Rn(this, t);
  }
  lengthSquared() {
    return _t(this);
  }
  length() {
    return Ft(this);
  }
  distanceSquared(t) {
    return Ut(this, t);
  }
  distance(t) {
    return Vn(this, t);
  }
  normalize() {
    return Wn(this, this);
  }
  angle() {
    return Xt(this);
  }
  angleDegree() {
    return qt(this);
  }
  rotate(t) {
    return ut(this, t, this);
  }
  isEqualTo(t) {
    return this.x === t.x && this.y === t.y;
  }
  clone() {
    return new V(this.x, this.y);
  }
  toObject() {
    return { x: this.x, y: this.y };
  }
  toArray() {
    return [this.x, this.y];
  }
}
const ee = se({
  Vector2D: V
}, ri);
class Q {
  constructor(t, n, o) {
    this.source = t, this.target = n, this.v = o;
  }
  static fromLinePosition(t) {
    const n = V.fromObject(t.p1), o = V.fromObject(t.p2);
    return new Q(n, o, _e(n, o));
  }
  static fromPositions(t, n) {
    const o = V.fromObject(t), i = V.fromObject(n);
    return new Q(o, i, _e(o, i));
  }
  static fromVectors(t, n) {
    return new Q(t, n, _e(t, n));
  }
}
function _e(e, t) {
  return t.clone().subtract(e);
}
function ai(e) {
  return [V.fromObject(e.p1), V.fromObject(e.p2)];
}
function li(e) {
  return new V((e.p1.x + e.p2.x) / 2, (e.p1.y + e.p2.y) / 2);
}
function dt(e, t) {
  return { p1: e, p2: t };
}
function $t(e, t, n) {
  const o = Q.fromLinePosition(e);
  return ci(o, t, n);
}
function ci(e, t, n) {
  const o = e.v.clone().normalize(), i = e.source.clone().add(o.clone().multiplyScalar(t)), s = e.target.clone().subtract(o.clone().multiplyScalar(n));
  let r = i.toObject(), a = s.toObject();
  const l = _e(i, s);
  if (e.v.angle() * l.angle() < 0) {
    const u = new V((r.x + a.x) / 2, (r.y + a.y) / 2), c = u.clone().add(o.multiplyScalar(0.5));
    r = u.toObject(), a = c.toObject();
  }
  return { p1: r, p2: a };
}
function ui(e) {
  return { p1: e.p2, p2: e.p1 };
}
function Ke(e) {
  const t = e.v.clone().normalize().rotate(Math.PI / 2);
  return Q.fromVectors(e.target, e.target.clone().add(t));
}
function Gt(e, t) {
  const n = t.v.clone().normalize(), o = t.source, i = ee.subtract(e, o), s = n.dot(i);
  return o.clone().add(n.multiplyScalar(s));
}
function yt(e, t, n, o) {
  if (!(ee.lengthSquared(ee.subtract(t, n)) - o * o <= Math.pow(1, -10))) return null;
  const r = Q.fromVectors(e, t), a = Gt(n, r), l = ee.length(ee.subtract(a, n));
  if (o < l) return null;
  if (o === l) return a;
  const u = Math.sqrt(ae(o, 2) - ae(l, 2)), c = r.v.normalize().multiplyScalar(u);
  return a.subtract(c);
}
function di(e, t, n, o, i) {
  if (!(ee.lengthSquared(ee.subtract(t, n)) - o * o <= Math.pow(1, -10))) return null;
  const a = Q.fromVectors(e, t), l = Gt(n, a), u = ee.length(ee.subtract(l, n));
  if (o < u) return null;
  if (o === u) return l;
  const c = Math.sqrt(ae(o, 2) - ae(u, 2)), d = a.v.normalize().multiplyScalar(c), h = l.clone().add(d), v = l.clone().subtract(d), E = i.distance(h), x = i.distance(v);
  return Math.abs(E - x) < 2 ? v : E < x ? h : v;
}
function Be(e, t) {
  const n = ee.subtract(t.source, e.source), o = e.v, i = t.v, s = ee.cross(n, o) / ee.cross(o, i);
  return t.source.clone().add(i.clone().multiplyScalar(s));
}
function et(e, t, n, o, i) {
  const s = e, a = n.clone().subtract(s), l = a.length(), u = t + o;
  if (u < l) return null;
  const c = Math.abs(t - o);
  if (l < c) return null;
  if (l === u) {
    const p = a.clone().normalize(), S = e.clone().add(p.multiplyScalar(t));
    return i ? S : [S, S];
  }
  if (l === c) {
    const p = a.clone().normalize(), S = t > o, O = e.clone().add(p.multiplyScalar(S ? t : -t));
    return i ? O : [O, O];
  }
  const d = t, h = o, v = (ae(l, 2) + ae(d, 2) - ae(h, 2)) / (2 * l * d), E = d * v, x = Math.sqrt(ae(d, 2) - ae(E, 2)), w = a.clone().normalize(), g = new V(-w.y, w.x), y = w.clone().multiplyScalar(E), k = g.clone().multiplyScalar(x), m = e.clone().add(y).add(k), f = e.clone().add(y).subtract(k);
  if (i) {
    const p = m.distance(i), S = f.distance(i);
    return p < S ? m : f;
  } else
    return [m, f];
}
function pn(e, t, n, o) {
  const i = Q.fromPositions(e, t), s = (n.width + n.strokeWidth) / 2 * o, r = (n.height + n.strokeWidth) / 2 * o, a = n.borderRadius > 0 ? (n.borderRadius + n.strokeWidth / 2) * o : 0, l = (i.v.angle() - Math.PI / 2) % Math.PI, u = Math.PI / 2 - l % Math.PI, c = r * Math.abs(Math.tan(l)), d = s * Math.abs(Math.tan(u)), h = c <= s - a, v = d <= r - a;
  if (h || v || a === 0)
    return Math.sqrt(h ? ae(r, 2) + ae(c, 2) : ae(s, 2) + ae(d, 2));
  {
    const E = t.x - s + a, x = t.y - r + a, w = t.x + s - a, g = t.y + r - a, y = [
      new V(E, x),
      new V(w, x),
      new V(w, g),
      new V(E, g)
    ], k = Math.floor((i.v.angleDegree() + 360) % 360 / 90), m = y[k], f = yt(
      i.source,
      Gt(m, i),
      m,
      a
    );
    return f ? _e(f, i.target).length() : _e(m, i.target).length() + a;
  }
}
function Hn(e, t, n, o, i) {
  const s = Q.fromLinePosition(e), r = s.v.clone().normalize(), a = o === 0 ? s.source : s.source.clone().add(r.clone().multiplyScalar(o * i)), l = o === 0 ? s.target : s.target.clone().subtract(r.clone().multiplyScalar(o * i)), u = (t.width / 2 + n) * i, c = new V(-r.y, r.x).multiplyScalar(u);
  let d = ee.subtract(a, c), h = ee.add(a, c), v = ee.subtract(l, c), E = ee.add(l, c);
  const x = s.v.angleDegree();
  return (x < -90 || x >= 90) && ([d, h] = [h, d], [v, E] = [E, v]), {
    source: { above: d, below: h },
    target: { above: v, below: E }
  };
}
function fi(e, t, n, o) {
  let i;
  n.type === "circle" ? i = n.radius + n.strokeWidth / 2 : i = pn(
    t,
    e,
    n,
    1
    // scale
  );
  let s;
  return o.type === "circle" ? s = o.radius + o.strokeWidth / 2 : s = pn(
    e,
    t,
    o,
    1
    // scale
  ), [i, s];
}
function Le(e, t, n) {
  const { x: o, y: i } = e, s = o - t.x, r = i - t.y;
  return {
    x: s * Math.cos(n) - r * Math.sin(n) + t.x,
    y: s * Math.sin(n) + r * Math.cos(n) + t.y
  };
}
function Lt(e) {
  return e > 0 ? -(Math.PI * 2 - e) : Math.PI * 2 + e;
}
function At(e, t, n, o) {
  const i = [], s = Q.fromVectors(t, e), r = Q.fromVectors(t, n);
  let a = Fe(s, r);
  o * a < 0 && (a = Lt(a));
  const l = V.fromObject(Le(e, t, -a / 2)), u = Q.fromVectors(t, l), c = Ke(u), d = Fe(s, u);
  let h = Ke(s);
  if (Math.abs(d) < Math.PI / 2) {
    const E = Be(h, c);
    i.push(E);
  } else {
    const E = V.fromObject(Le(l, t, d / 2)), x = Ke(
      Q.fromVectors(t, V.fromObject(E))
    ), w = Be(h, x), g = Be(x, c);
    i.push(w, E, g);
  }
  i.push(l);
  const v = Fe(r, u);
  if (h = Ke(r), Math.abs(v) < Math.PI / 2) {
    const E = Be(h, c);
    i.push(E);
  } else {
    const E = V.fromObject(Le(l, t, v / 2)), x = Ke(
      Q.fromVectors(t, V.fromObject(E))
    ), w = Be(c, x), g = Be(x, h);
    i.push(w, E, g);
  }
  return i;
}
function Fe(e, t) {
  return Math.atan2(
    e.v.y * t.v.x - e.v.x * t.v.y,
    e.v.x * t.v.x + e.v.y * t.v.y
  );
}
function hi(e, t, n) {
  const o = e.x, i = e.y, s = t.x, r = t.y, a = n.x, l = n.y, u = o - s, c = i - r, d = a - s, h = l - r;
  if (u === 0 && c === 0 || d === 0 && h === 0)
    return [e, 0];
  const v = (h * (u * (o + s) + c * (i + r)) - c * (d * (a + s) + h * (l + r))) / (2 * u * h - 2 * c * d), E = (-d * (u * (o + s) + c * (i + r)) + u * (d * (a + s) + h * (l + r))) / (2 * u * h - 2 * c * d), x = Math.sqrt(Math.pow(o - v, 2) + Math.pow(i - E, 2));
  return [new V(v, E), x];
}
function He(e) {
  return e.type == "circle" ? e.radius : Math.min(e.width, e.height) / 2;
}
function vi(e) {
  const t = Object.values(e);
  if (t.length === 0)
    return {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    };
  const n = {
    top: t[0].y,
    bottom: t[0].y,
    left: t[0].x,
    right: t[0].x
  };
  return t.forEach((o) => {
    n.top = Math.min(o.y, n.top), n.bottom = Math.max(o.y, n.bottom), n.left = Math.min(o.x, n.left), n.right = Math.max(o.x, n.right);
  }), n;
}
function st(...e) {
  return e.find((t) => !!t);
}
const gi = Number.EPSILON * 100;
function pi(e, t, n, o, i, s, r, a) {
  var x, w;
  const l = e.edges, u = e.directions, c = l.map((g, y) => bi(g, u[y], o[g.edgeId])), d = [];
  let h = !1, v = !1;
  {
    const g = c[0];
    let y = He(t[g.source].shape) * i;
    const k = a + (r === "edgeOfNode" ? y : 0), m = k <= 0 ? g.line.source : bn(g, k, n, !0);
    d.push(m), y = He(t[g.target].shape) * i, a > 0 && ee.distance(g.line.source, g.line.target) <= k + y && (h = !0);
  }
  const E = l.length;
  for (let g = 1; g < E; g++) {
    const y = c[g - 1], k = c[g], m = k.source, f = V.fromObject((x = n[m]) != null ? x : { x: 0, y: 0 }), p = mi(y, k, f), S = He(t[m].shape) * i, O = Math.max(S * (2 / 3), S - 4 * i), I = Zt(y), z = Zt(k), T = rt(y, f, O, I), A = rt(k, f, O, !z), R = rt(y, f, S, I), Y = rt(k, f, S, !z);
    let B;
    if (p) {
      const F = ee.distance(p, f);
      if (F < O)
        B = [
          st(T, R, y.line.target),
          p,
          st(A, Y, k.line.source)
        ];
      else if (F <= S) {
        let ye, ie;
        R && T ? ye = ee.distance(p, T) < ee.distance(p, R) ? T : R : ye = R || y.line.target, Y && A ? ie = ee.distance(p, A) < ee.distance(p, Y) ? A : Y : ie = Y || k.line.source, B = [ye, p, ie];
      } else
        T && A ? B = [T, f, A] : R && Y ? B = [R, f, Y] : B = [
          st(T, R, y.line.target),
          f,
          st(A, Y, k.line.source)
        ];
    } else
      T && A ? B = [T, f, A] : R && Y ? B = [R, f, Y] : B = [y.line.target, f, k.line.source];
    if (y.curve) {
      const F = d[d.length - 1];
      if (F) {
        const ye = F instanceof Array ? F[F.length - 1] : F;
        let ie;
        B instanceof Array ? ie = s ? B[0] : B[1] : ie = B;
        const ke = At(
          ye,
          y.curve.circle.center,
          ie,
          y.curve.theta
        );
        B instanceof Array && s ? d.push([...ke, ...B]) : d.push([...ke, ie]);
      }
    } else if (y.loop) {
      const [F, ye, ie] = wn(f, y, S);
      d.push(F), d.push(ie), B instanceof Array && s ? d.push([ye, B[1], B[2]]) : d.push(B[2]);
    } else
      s || !(B instanceof Array) ? d.push(B) : k.curve ? d.push(B[1]) : k.loop ? d.push(B[0]) : d.push(B[0], B[2]);
  }
  {
    const g = c[c.length - 1];
    let y = He(t[g.target].shape) * i;
    const k = a + (r === "edgeOfNode" ? y : 0), m = k <= 0 ? g.line.target : bn(g, k, n, !1);
    if (y = He(t[g.source].shape) * i, g.loop) {
      const f = V.fromObject((w = n[g.target]) != null ? w : { x: 0, y: 0 }), [p, S, O] = wn(f, g, y);
      d.push(p), d.push(O);
    } else if (g.curve) {
      const f = d[d.length - 1], p = f instanceof Array ? f[f.length - 1] : f, S = At(
        p,
        g.curve.circle.center,
        m,
        g.curve.theta
      );
      d.push([...S, m]);
    } else
      d.push(m);
    a > 0 && ee.distance(g.line.source, g.line.target) <= k + y && (v = !0);
  }
  return h && (d.shift(), d[0] instanceof Array && d.unshift(d[0][0])), v && d.pop(), d;
}
function mn(e) {
  const t = e.length;
  if (t === 0) return [];
  if (t <= 1) return [!0];
  const n = [];
  let o = null, i = !0;
  for (let s = 0; s < t; s++) {
    const r = e[s].edge.source, a = e[s].edge.target;
    if (s === 0)
      if (t > 2) {
        const l = _n(e, 0);
        l === null ? i = !0 : i = l === a;
      } else
        i = [e[1].edge.source, e[1].edge.target].includes(a);
    else r === a ? i = !0 : i = o === r;
    n.push(i), o = i ? a : r;
  }
  return n;
}
function _n(e, t) {
  const n = e[t], o = e[t + 1], i = [n.edge.source, n.edge.target].sort(), s = [o.edge.source, o.edge.target].sort();
  if (i[0] === i[1])
    return i[0];
  if (s[0] === s[1])
    return s[0];
  if (n.edgeId === o.edgeId || i[0] === s[0] && i[1] === s[1]) {
    if (t >= e.length - 2)
      return null;
    {
      const r = _n(e, t + 1);
      return r === null ? null : r === i[1] ? i[0] : i[1];
    }
  } else
    return s.includes(i[1]) ? i[1] : i[0];
}
function bn(e, t, n, o) {
  const i = o ? e.source : e.target, s = e.curve;
  if (s) {
    let r = t / s.circle.radius;
    return s.theta > 0 && (r *= -1), o || (r *= -1), V.fromObject(
      Le(
        o ? e.line.source : e.line.target,
        s.circle.center,
        r
      )
    );
  } else {
    let r, a;
    if (o ? (r = e.line.target, a = e.line.source) : (r = e.line.source, a = e.line.target), n[i]) {
      const l = yt(
        r,
        a,
        V.fromObject(n[i]),
        t
      );
      return l === null ? r : l;
    } else
      return r;
  }
}
function mi(e, t, n) {
  let o = null;
  if (e.loop || t.loop)
    o = null;
  else if (e.curve)
    if (t.curve) {
      if (e.line.target.isEqualTo(t.line.source))
        return e.line.target.clone();
      o = et(
        e.curve.circle.center,
        e.curve.circle.radius,
        t.curve.circle.center,
        t.curve.circle.radius,
        e.curve.center
      );
    } else
      o = di(
        t.line.target,
        t.line.source,
        e.curve.circle.center,
        e.curve.circle.radius,
        n
      );
  else if (t.curve)
    o = yt(
      e.line.source,
      e.line.target,
      t.curve.circle.center,
      t.curve.circle.radius
    );
  else {
    const i = yn(e.line), s = yn(t.line);
    !isFinite(i) && !isFinite(s) || Math.abs(i - s) < gi ? o = null : o = Be(e.line, t.line);
  }
  return o;
}
function rt(e, t, n, o) {
  if (e.loop) {
    const i = et(
      t,
      n,
      e.loop.center,
      e.loop.radius[0]
    );
    return i ? o ? i[0] : i[1] : null;
  } else return e.curve ? et(
    t,
    n,
    e.curve.circle.center,
    e.curve.circle.radius,
    V.fromObject(e.curve.center)
  ) : yt(
    o ? e.line.source : e.line.target,
    o ? e.line.target : e.line.source,
    t,
    n
  );
}
function bi(e, t, n) {
  let o = n.origin, i = e.edge.source, s = e.edge.target, r = n.curve;
  const a = n.loop;
  a ? o = n.position : t || (o = ui(o), i = e.edge.target, s = e.edge.source, r && (r = qe(se({}, r), { theta: -r.theta })));
  const l = Q.fromLinePosition(o);
  return {
    edgeId: e.edgeId,
    source: i,
    target: s,
    line: l,
    direction: t,
    curve: r,
    loop: a
  };
}
function yn(e) {
  return (e.target.y - e.source.y) / (e.target.x - e.source.x);
}
function wn(e, t, n) {
  const { radius: o, center: i } = q(t.loop, "Loop of edge parameter"), [s, r] = o, a = et(e, n, i, o[0]);
  let [l, u] = a ? a.reverse() : [t.line.source, t.line.target];
  const c = Zt(t);
  c || ([l, u] = [u, l]);
  const d = l, h = u, v = V.fromObject(d).subtract(i).angleDegree();
  let w = (V.fromObject(h).subtract(i).angleDegree() + 360 - v) % 360 >= 180;
  return w = c ? w : !w, [d, h, `A ${s} ${r} 0 ${w ? 1 : 0} ${c ? 1 : 0} ${h.x} ${h.y}`];
}
function Zt(e) {
  return e.loop ? e.direction ? e.loop.isClockwise : !e.loop.isClockwise : !0;
}
function Ot(e, t, n, o, i, s, r) {
  const a = Oe({});
  U(
    () => new Set(Object.keys(e.value)),
    (u, c) => {
      c || (c = /* @__PURE__ */ new Set([]));
      for (const d of u)
        c.has(d) || yi(e, a, d, !1, t, i);
      for (const d of c)
        u.has(d) || (n.delete(d), o.delete(d), s == null || s(d, a[d]), delete a[d]);
    },
    { immediate: !0 }
  ), U(
    () => [...n],
    (u, c) => {
      const d = c ? u.filter((v) => !c.includes(v)) : u, h = c ? c.filter((v) => !u.includes(v)) : [];
      d.forEach((v) => {
        const E = a[v];
        E && !E.selected && (E.selected = !0);
      }), h.forEach((v) => {
        const E = a[v];
        E && E.selected && (E.selected = !1);
      });
    },
    { immediate: !0 }
    // for specified from the beginning
  ), U(
    () => [...o],
    (u, c) => {
      const d = u.filter((v) => !c.includes(v)), h = c.filter((v) => !u.includes(v));
      d.forEach((v) => {
        const E = a[v];
        E && !E.hovered && (E.hovered = !0);
      }), h.forEach((v) => {
        const E = a[v];
        E && E.hovered && (E.hovered = !1);
      });
    }
  );
  const l = C(() => {
    const u = r ? r() : Object.values(a);
    return t.zOrder.enabled ? wi(u, t.zOrder, o, n) : u;
  });
  return { states: a, zOrderedList: l };
}
function yi(e, t, n, o, i, s) {
  const r = {
    id: n,
    selected: o,
    hovered: !1,
    selectable: C(() => e.value[n] ? $.value(i.selectable, e.value[n]) : b(r.selectable)),
    zIndex: C(() => e.value[n] ? $.value(i.zOrder.zIndex, e.value[n]) : b(r.zIndex))
  };
  t[n] = r, s(
    e,
    n,
    t[n]
    /* get reactive object */
  );
}
function wi(e, t, n, o) {
  return t.bringToFrontOnHover && t.bringToFrontOnSelected ? e.sort((i, s) => {
    const r = n.has(i.id), a = n.has(s.id);
    if (r != a)
      return r ? 1 : -1;
    const l = o.has(i.id), u = o.has(s.id);
    return l != u ? l ? 1 : -1 : i.zIndex - s.zIndex;
  }) : t.bringToFrontOnHover ? e.sort((i, s) => {
    const r = n.has(i.id), a = n.has(s.id);
    return r != a ? r ? 1 : -1 : i.zIndex - s.zIndex;
  }) : t.bringToFrontOnSelected ? e.sort((i, s) => {
    const r = o.has(i.id), a = o.has(s.id);
    return r != a ? r ? 1 : -1 : i.zIndex - s.zIndex;
  }) : e.sort((i, s) => i.zIndex - s.zIndex);
}
function Ei(e) {
  return typeof btoa === void 0 ? Buffer.from(e).toString("base64").replaceAll("=", "") : btoa(e).replaceAll("=", "");
}
function xi() {
  return { markers: Oe({}), referenceCount: {} };
}
function ki(e) {
  const { markers: t, referenceCount: n } = e;
  function o(a, l) {
    var c;
    const u = (c = n[a]) != null ? c : 0;
    n[a] = u + 1, u || (t[a] = l);
  }
  function i(a) {
    var u;
    const l = (u = n[a]) != null ? u : 0;
    l && (l - 1 === 0 ? (delete t[a], delete n[a]) : n[a] = l - 1);
  }
  function s(a) {
    a && i(a);
  }
  function r(a, l, u, c, d) {
    if (a.type === "none") {
      s(u);
      return;
    }
    if (a.type === "custom")
      return s(u), a.customId;
    const h = Pi(a, l, c), v = Si(h, d);
    return v === u || (s(u), o(v, h)), v;
  }
  return {
    makeMarker: r,
    clearMarker: s
  };
}
function Pi(e, t, n) {
  var o;
  return qe(se({}, e), {
    color: (o = e.color) != null ? o : n,
    isSource: t
  });
}
function Si(e, t) {
  const n = Ei(e.color), o = e.isSource ? "L" : "R", i = e.units === "strokeWidth" ? "rel" : "abs";
  return `marker_${t}_${e.type}_${e.width}_${e.height}_${e.margin}_${e.offset}_${n}_${o}_${i}`;
}
function zt(e, t, n) {
  return {
    objects: e,
    selected: t,
    hovered: n
  };
}
const Fn = Symbol("states"), Mi = {
  type: "none",
  width: 0,
  height: 0,
  margin: 0,
  offset: 0,
  units: "strokeWidth",
  color: null
};
function Ci(e, t, n, o, i, s, r, a) {
  const l = Oe({}), u = Ie({});
  me(() => {
    const m = Object.fromEntries(
      Object.keys(e.objects.value).map((f) => [f, {}])
    );
    Object.entries(t.objects.value).forEach(([f, p]) => {
      m != null && m[p.source] || (m[p.source] = {}), m != null && m[p.target] || (m[p.target] = {}), m[p.source][f] = p.target, m[p.target][f] = p.source;
    }), lt(u, m);
  });
  const {
    states: c,
    zOrderedList: d
    //
  } = Ot(
    e.objects,
    o.node,
    e.selected,
    e.hovered,
    (m, f, p) => {
      Ti(
        m,
        f,
        p,
        o.node,
        u,
        i,
        s
      );
    },
    (m, f) => {
      const p = i.nodes;
      delete p[m];
    }
  ), h = Jo(), v = ti(e.objects, t.objects, o), E = j([]), {
    states: x,
    zOrderedList: w
    //
  } = Ot(
    t.objects,
    o.edge,
    t.selected,
    t.hovered,
    (m, f, p) => {
      $i(
        m,
        f,
        p,
        o.edge,
        r,
        c,
        v,
        i,
        a,
        h
      );
    },
    (m, f) => {
      var p;
      (p = f.stopWatchHandle) == null || p.call(f);
    },
    () => E.value
  );
  me(() => {
    E.value = Li(v.edgeGroups, x);
  }), U(
    v.edgeGroups,
    (m) => Di(l, v, o),
    { immediate: !0 }
  );
  const {
    states: g,
    zOrderedList: y
    //
  } = Ot(
    n.objects,
    o.path,
    n.selected,
    n.hovered,
    (m, f, p) => {
      const S = p;
      S.clickable = C(() => m.value[f] ? $.value(o.path.clickable, m.value[f]) : !1), S.hoverable = C(() => m.value[f] ? $.value(o.path.hoverable, m.value[f]) : !1), S.path = m.value[f], S.edges = xn(S.path, t), S.directions = mn(S.edges), S.stopWatchHandle = U(
        () => m.value[f].edges,
        () => {
          S.path = m.value[f], S.edges = xn(S.path, t), S.directions = mn(S.edges);
        }
      );
    },
    (m, f) => {
      var p;
      (p = f.stopWatchHandle) == null || p.call(f);
    }
  ), k = {
    nodeStates: c,
    edgeStates: x,
    edgeGroupStates: v,
    summarizedEdgeStates: l,
    pathStates: g,
    layouts: i,
    nodeZOrderedList: d,
    edgeZOrderedList: w,
    pathZOrderedList: y
  };
  return Ze(Fn, k), k;
}
function Oi(e) {
  return e.summarized;
}
function Se() {
  return q(De(Fn), "states");
}
function zi(e, t, n, o) {
  return n && o.hover ? $.values(o.hover, e) : Un(e, t, o);
}
function Un(e, t, n) {
  return t && n.selected ? $.values(n.selected, e) : $.values(n.normal, e);
}
function Ti(e, t, n, o, i, s, r) {
  var a, l;
  !s.nodes[t] && ((a = r.nodes) != null && a[t]) && (s.nodes[t] = se({}, (l = r.nodes) == null ? void 0 : l[t])), n.shape = C(() => e.value[t] ? zi(e.value[t], n.selected, n.hovered, o) : b(n.shape)), n.staticShape = C(() => e.value[t] ? Un(e.value[t], n.selected, o) : b(n.staticShape)), n.label = C(() => e.value[t] ? $.values(o.label, e.value[t]) : b(n.label)), n.labelText = C(() => {
    var u, c;
    return o.label.text instanceof Function ? b(n.label).text : e.value[t] ? (c = (u = e.value[t]) == null ? void 0 : u[b(n.label).text]) != null ? c : "" : b(n.labelText);
  }), n.draggable = C(() => e.value[t] ? $.value(o.draggable, e.value[t]) : b(n.draggable)), n.oppositeNodeIds = Ce(i, t), n.oppositeNodes = C(() => Object.entries(n.oppositeNodeIds).reduce(
    (u, c) => {
      const [d, h] = c, v = s.nodes[h];
      return v && (u[d] = { nodeId: h, pos: se({}, v) }), u;
    },
    {}
  ));
}
function Ii(e, t, n, o) {
  return t ? $.values(o.selected, e) : n && o.hover ? $.values(o.hover, e) : $.values(o.normal, e);
}
function En(e) {
  return e.type === "none" ? Mi : e;
}
function $i(e, t, n, o, i, s, r, a, l, u) {
  const { makeMarker: c, clearMarker: d } = ki(i);
  Object.assign(n, {
    origin: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },
    labelPosition: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },
    position: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } }
  }), n.label = C(() => e.value[t] ? $.values(o.label, e.value[t]) : b(n.label));
  const h = C(() => {
    const g = e.value[t], y = Ii(g, n.selected, n.hovered, o);
    isNaN(+y.width) && (console.warn(
      "[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]",
      t,
      y.width
    ), y.width = 1), (y.color === void 0 || y.color === null) && (console.warn(
      "[v-network-graph] Edge color is invalid value. id=[%s] value=[%s]",
      t,
      y.color
    ), y.color = "#000000");
    let k = $.value(o.normal.width, g);
    isNaN(+k) && (k = 1);
    const m = En($.values(o.marker.source, [g, y])), f = En($.values(o.marker.target, [g, y]));
    return { stroke: y, normalWidth: k, source: m, target: f };
  });
  n.line = h;
  const v = Ce(
    r.edgeLayoutPoints,
    t
  ), E = Ce(r.summarizedEdges, t), x = me(() => {
    var B, F, ye, ie, ke, Ne, Xe;
    const g = e.value[t];
    if (!g) return;
    const y = (B = s[g.source]) == null ? void 0 : B.staticShape, k = (F = s[g.target]) == null ? void 0 : F.staticShape;
    if (!y || !k)
      return;
    const m = (ye = a.nodes[g == null ? void 0 : g.source]) != null ? ye : { x: 0, y: 0 }, f = (ie = a.nodes[g == null ? void 0 : g.target]) != null ? ie : { x: 0, y: 0 }, p = ni(
      v.value,
      (ke = E.value) != null ? ke : !1,
      m,
      f,
      l.value,
      o.keepOrder
    ), [S, O] = fi(m, f, y, k), I = l.value;
    n.labelPosition = $t(
      p,
      S * I,
      O * I
    );
    let z = 0, T = 0;
    const A = h.value;
    if (A.source.type !== "none") {
      const le = A.source;
      z = le.margin + le.width, le.units === "strokeWidth" && (z *= A.normalWidth);
    }
    if (A.target.type !== "none") {
      const le = A.target;
      T = le.margin + le.width, le.units === "strokeWidth" && (T *= A.normalWidth);
    }
    o.margin && (z += o.margin, T += o.margin);
    const R = !!o.margin || A.source.type !== "none" || A.target.type !== "none";
    if (g.source === g.target) {
      n.origin = dt(m, f);
      const le = $.values(o.selfLoop, g), [Ve, ge] = Zi(
        m,
        y,
        le,
        R,
        z,
        T,
        (Xe = (Ne = v.value) == null ? void 0 : Ne.pointInGroup) != null ? Xe : 0,
        I
      );
      n.position = Ve, n.loop = ge, n.curve = void 0;
      return;
    } else
      n.loop = void 0;
    if (R && (z += S, T += O), o.type === "straight" || E.value)
      n.origin = p, n.curve = void 0, z === 0 && T === 0 ? n.position = n.origin : n.position = $t(n.origin, z * I, T * I);
    else {
      n.origin = dt(m, f);
      const le = v.value ? v.value.groupWidth / 2 - v.value.pointInGroup : 0, [Ve, ge] = Ai(
        n.origin,
        p,
        le,
        z * I,
        T * I
      );
      n.position = Ve, n.curve = ge;
    }
  }), w = me(() => {
    e.value[t] && (n.sourceMarkerId = c(
      h.value.source,
      !0,
      n.sourceMarkerId,
      h.value.stroke.color,
      u
    ), n.targetMarkerId = c(
      h.value.target,
      !1,
      n.targetMarkerId,
      h.value.stroke.color,
      u
    ));
  });
  n.stopWatchHandle = () => {
    x(), w(), d(n.sourceMarkerId), d(n.targetMarkerId);
  };
}
function Li(e, t) {
  return Object.entries(e).map(([n, o]) => {
    var i;
    return o.summarize ? {
      id: (i = Object.keys(o.edges)[0]) != null ? i : n,
      summarized: !0,
      key: n,
      group: o,
      zIndex: Object.keys(o.edges).map((s) => {
        var r, a;
        return (a = (r = t[s]) == null ? void 0 : r.zIndex) != null ? a : 0;
      }).reduce((s, r) => Math.max(s, r))
    } : Object.entries(o.edges).map(
      ([s, r]) => {
        var a, l;
        return {
          id: s,
          summarized: !1,
          key: s,
          edge: r,
          zIndex: (l = (a = t[s]) == null ? void 0 : a.zIndex) != null ? l : 0
        };
      }
    );
  }).flat();
}
function Ai(e, t, n, o, i) {
  const s = Q.fromLinePosition(e), r = Q.fromLinePosition(t), a = li(t), [l, u] = hi(
    s.source,
    s.target,
    a
  );
  let c, d;
  if (u === 0)
    return [e, d];
  if (n === 0)
    return o === 0 && i === 0 ? c = e : c = $t(e, o, i), [c, d];
  const h = Q.fromVectors(l, a), v = Fe(
    Q.fromVectors(l, s.source),
    h
  );
  if (o === 0 && i === 0)
    c = e;
  else {
    let g = o / u, y = i / u;
    v > 0 && (g *= -1, y *= -1), c = dt(
      Le(s.source, l, g),
      Le(s.target, l, -y)
    );
    let k = Fe(
      Q.fromVectors(l, s.source),
      Q.fromVectors(l, s.target)
    ), m = Fe(
      Q.fromPositions(l, c.p1),
      Q.fromPositions(l, c.p2)
    );
    if (v * k < 0 && (k = Lt(k), v * m < 0 && (m = Lt(m))), k * m < 0) {
      const f = a.clone().add(r.v.normalize().multiplyScalar(0.5));
      return c = dt(a, f), [c, d];
    }
  }
  const [E, x] = ai(c), w = At(E, l, x, v).map((g) => g.toObject());
  return d = {
    center: a,
    theta: v,
    circle: { center: l, radius: u },
    control: w
  }, [c, d];
}
function Zi(e, t, n, o, i, s, r, a) {
  const l = a, u = (n.radius + r / 2) * l, c = n.offset * l + u, d = (n.angle - 90) * (Math.PI / 180), h = V.fromObject({
    x: e.x + c * Math.cos(d),
    y: e.y + c * Math.sin(d)
  }), v = n.isClockwise;
  let E, x;
  if (o) {
    const m = et(
      h,
      u,
      V.fromObject(e),
      He(t) * l
    );
    if (m) {
      [E, x] = m;
      let f = 1;
      if (v || ([E, x] = [x, E], f = -1), i !== 0 || s !== 0) {
        const p = i * l / u * f, S = s * l / u * f;
        E = Le(E, h, p), x = Le(x, h, -S);
      }
    }
  }
  if (E === void 0 || x === void 0) {
    const m = V.fromObject(e).subtract(h).normalize().multiplyScalar(u);
    let f = 1 * (Math.PI / 180);
    v || (f *= -1), E = h.clone().add(ut(m, f)), x = h.clone().add(ut(m, -f));
  }
  const w = V.fromObject(E).subtract(h).angleDegree(), k = (V.fromObject(x).subtract(h).angleDegree() + 360 - w) % 360 >= 180;
  return [
    { p1: E, p2: x },
    {
      center: h,
      radius: [u, u],
      isLargeArc: v ? k : !k,
      isClockwise: v
    }
  ];
}
function Di(e, t, n) {
  const o = t.edgeGroups;
  Object.entries(o).filter(([i, s]) => s.summarize && !(i in e)).forEach(([i, s]) => {
    const r = { stroke: void 0 };
    r.stroke = C(
      () => $.values(n.edge.summarized.stroke, s.edges)
    ), e[i] = r;
  }), Object.keys(e).forEach((i) => {
    var s;
    (s = t.edgeGroups[i]) != null && s.summarize || delete e[i];
  });
}
function xn(e, t) {
  return e.edges.map((n) => ({ edgeId: n, edge: t.objects.value[n] })).filter((n) => n.edge);
}
class Qe {
  static valueOf(t) {
    return Array.from(t.values());
  }
}
const Ni = 3, ji = 6, Xn = 500;
function ct(e) {
  return e === "touch" ? ji : Ni;
}
function Kt(e, t, n, o) {
  let i = e.get(t);
  if (i)
    i.id !== n && (i = void 0);
  else {
    const a = Array.from(e.entries()).find(([l, u]) => u.id === n);
    if (a) {
      const [l, u] = a;
      e.delete(l), i = u;
    }
  }
  let s, r;
  return [i, s, r] = qn(i, o, n), e.set(t, i), [s, r];
}
function qn(e, t, n) {
  const o = Date.now();
  e && o - e.lastTime <= Xn ? (e.count++, e.lastTime = o) : e = { count: 1, lastTime: o, id: n };
  const i = {
    view: window,
    screenX: t.screenX,
    screenY: t.screenY,
    clientX: t.clientX,
    clientY: t.clientY,
    ctrlKey: t.ctrlKey,
    shiftKey: t.shiftKey,
    altKey: t.altKey,
    metaKey: t.metaKey,
    button: t.button,
    buttons: t.buttons,
    detail: e.count
  };
  let s, r;
  return t instanceof PointerEvent ? (Object.assign(i, {
    pointerId: t.pointerId,
    width: t.width,
    height: t.height,
    pressure: t.pressure,
    tangentialPressure: t.tangentialPressure,
    tiltX: t.tiltX,
    tiltY: t.tiltY,
    twist: t.twist,
    pointerType: t.pointerType,
    isPrimary: t.isPrimary
  }), s = new PointerEvent("click", i), e.count === 2 && (r = new PointerEvent("dblclick", i))) : (s = new MouseEvent("click", i), e.count === 2 && (r = new MouseEvent("dblclick", i))), [e, s, r];
}
function Yt(e) {
  const t = Date.now();
  Array.from(e.entries()).filter(([n, o]) => t - o.lastTime > Xn).map(([n, o]) => e.delete(n));
}
function Bi(e, t, n, o, i, s, r) {
  const a = {
    pointers: /* @__PURE__ */ new Map(),
    follow: {
      followedPointerId: -1,
      nodeBasePositions: {}
    },
    hoveredNodesPre: /* @__PURE__ */ new Set(),
    clicks: /* @__PURE__ */ new Map()
  }, l = {
    pointermove: v,
    pointerup: x,
    pointercancel: E
  };
  function u(m) {
    const f = a.follow.followedPointerId === m.pointerId, p = i.has(m.nodeId), S = !(m.pointerId in a.pointers);
    if (f && S || f && !p) {
      const O = Qe.valueOf(a.pointers).find((I) => i.has(I.nodeId));
      if (!O) {
        a.follow = { followedPointerId: -1, nodeBasePositions: {} };
        return;
      }
      m = O, a.follow.followedPointerId = m.pointerId;
    } else {
      const O = a.pointers.get(a.follow.followedPointerId);
      if (!O) {
        a.follow = { followedPointerId: -1, nodeBasePositions: {} };
        return;
      }
      m = O;
    }
    if (f || p) {
      const O = Qe.valueOf(a.pointers).map((I) => I.nodeId);
      a.follow.nodeBasePositions = Object.fromEntries(
        Array.from(i).filter((I) => !O.includes(I)).filter((I) => {
          var z;
          return (z = e[I]) == null ? void 0 : z.draggable;
        }).map((I) => [I, Tt(t.nodes, I)])
      ), m.dragBasePosition = se({}, m.latestPosition), m.nodeBasePosition = Tt(t.nodes, m.nodeId);
    }
  }
  U(i, (m) => {
    const f = a.pointers.get(a.follow.followedPointerId);
    f && u(f), m.size > 0 && n.selectionMode.value !== "node" ? n.selectionMode.value = "node" : m.size === 0 && n.selectionMode.value === "node" && (n.selectionMode.value = "container");
  }), U(n.selectionMode, (m) => {
    m !== "node" && i.clear();
  });
  function c(m, f) {
    const p = m.dragBasePosition.x - f.pageX, S = m.dragBasePosition.y - f.pageY, O = a.follow.followedPointerId == m.pointerId ? se({
      [m.nodeId]: m.nodeBasePosition
    }, a.follow.nodeBasePositions) : { [m.nodeId]: m.nodeBasePosition }, I = s.value;
    return Object.fromEntries(
      Object.entries(O).map(([z, T]) => [
        z,
        {
          x: T.x - p / I,
          y: T.y - S / I
        }
      ])
    );
  }
  function d(m, f) {
    var S, O;
    if (f.isTrusted || f.shiftKey && !["container", "node"].includes(n.selectionMode.value))
      return;
    n.selectionMode.value = "node";
    const p = (O = (S = e[m]) == null ? void 0 : S.selectable) != null ? O : !1;
    if (p) {
      const I = Qe.valueOf(a.pointers).filter((z) => i.has(z.nodeId)).length > 0;
      f.shiftKey || I ? i.has(m) ? i.delete(m) : typeof p == "number" && i.size >= p || i.add(m) : i.has(m) || (i.clear(), i.add(m));
    }
    r.emit("node:click", { node: m, event: f });
  }
  function h(m, f) {
    f.isTrusted || r.emit("node:dblclick", { node: m, event: f });
  }
  function v(m) {
    var O;
    m.stopPropagation();
    const f = a.pointers.get(m.pointerId);
    if (!f)
      return;
    f.latestPosition = { x: m.pageX, y: m.pageY }, f.moveCounter++;
    const p = ct(m.pointerType);
    if (f.moveCounter <= p || !((O = e[f.nodeId]) != null && O.draggable))
      return;
    if (f.moveCounter === p + 1) {
      const I = c(f, {
        pointerId: f.pointerId,
        pageX: f.dragBasePosition.x,
        pageY: f.dragBasePosition.y
      });
      r.emit("node:dragstart", I);
    }
    const S = c(f, m);
    r.emit("node:pointermove", S);
  }
  function E(m) {
    m.stopPropagation();
    let f = a.pointers.get(m.pointerId);
    if (f) {
      for (f of a.pointers.values()) {
        const p = f.nodeId, S = ct(m.pointerType);
        if (f.moveCounter > S) {
          const I = c(f, {
            pointerId: f.pointerId,
            pageX: f.latestPosition.x,
            pageY: f.latestPosition.y
          });
          r.emit("node:dragend", I);
        }
        r.emit("node:pointerup", { node: p, event: m });
      }
      a.pointers.clear(), a.follow = { followedPointerId: -1, nodeBasePositions: {} }, he(l).forEach(([p, S]) => {
        document.removeEventListener(p, S);
      }), n.viewMode.value = "default";
    }
  }
  function x(m) {
    var I, z, T;
    m.stopPropagation();
    const f = a.pointers.get(m.pointerId);
    if (!f)
      return;
    a.pointers.delete(m.pointerId);
    const p = f.nodeId, S = ct(m.pointerType), O = f.moveCounter > S;
    if (O) {
      if ((I = e[f.nodeId]) != null && I.draggable) {
        const A = c(f, m);
        r.emit("node:dragend", A), r.emit("node:pointerup", { node: p, event: m });
      }
    } else
      r.emit("node:pointerup", { node: p, event: m });
    if (!O) {
      const [A, R] = Kt(
        a.clicks,
        f.pointerId,
        p,
        m
      );
      (z = f.eventTarget) == null || z.dispatchEvent(A), R && ((T = f.eventTarget) == null || T.dispatchEvent(R));
    }
    a.pointers.size === 0 ? (a.follow = { followedPointerId: -1, nodeBasePositions: {} }, he(l).forEach(([A, R]) => {
      document.removeEventListener(A, R);
    }), Yt(a.clicks), n.viewMode.value = "default") : u(f), o.clear(), a.hoveredNodesPre.forEach(o.add, o);
  }
  function w(m, f) {
    if (f.button == 2 || (f.stopPropagation(), !["default", "node"].includes(n.viewMode.value)))
      return;
    a.pointers.size == 0 && (n.viewMode.value = "node", he(l).forEach(([S, O]) => {
      document.addEventListener(S, O);
    }));
    const p = {
      pointerId: f.pointerId,
      nodeId: m,
      moveCounter: 0,
      nodeBasePosition: Tt(t.nodes, m),
      dragBasePosition: { x: f.pageX, y: f.pageY },
      latestPosition: { x: f.pageX, y: f.pageY },
      eventTarget: f.currentTarget
    };
    a.pointers.set(f.pointerId, p), i.has(m) && (a.follow.followedPointerId < 0 ? (a.follow.followedPointerId = f.pointerId, u(p)) : delete a.follow.nodeBasePositions[p.nodeId]), r.emit("node:pointerdown", { node: m, event: f });
  }
  function g(m, f) {
    a.hoveredNodesPre.add(m), !(a.pointers.size > 0) && (o.add(m), r.emit("node:pointerover", { node: m, event: f }));
  }
  function y(m, f) {
    a.hoveredNodesPre.delete(m), !(a.pointers.size > 0) && (o.delete(m), r.emit("node:pointerout", { node: m, event: f }));
  }
  function k(m, f) {
    f.stopPropagation(), r.emit("node:contextmenu", { node: m, event: f });
  }
  return {
    handleNodePointerDownEvent: w,
    handleNodePointerOverEvent: g,
    handleNodePointerOutEvent: y,
    handleNodeClickEvent: d,
    handleNodeDoubleClickEvent: h,
    handleNodeContextMenu: k
  };
}
function Tt(e, t) {
  var o;
  const n = (o = e[t]) != null ? o : { x: 0, y: 0 };
  return se({}, n);
}
function Ri(e, t, n, o, i) {
  const s = {
    pointers: /* @__PURE__ */ new Map(),
    // <PointerId, ...>
    pointerPeekCount: 0,
    clicks: /* @__PURE__ */ new Map()
  }, r = {
    pointerup: l,
    pointercancel: u
  };
  U(o, (f) => {
    f.size > 0 && t.selectionMode.value !== "edge" ? t.selectionMode.value = "edge" : f.size === 0 && t.selectionMode.value === "edge" && (t.selectionMode.value = "container");
  }), U(t.selectionMode, (f) => {
    f !== "edge" && o.clear();
  });
  function a(f, p) {
    if (p.button == 2 || (p.stopPropagation(), !["default", "edge"].includes(t.viewMode.value)))
      return;
    s.pointers.size == 0 && (t.viewMode.value = "edge", he(r).forEach(([O, I]) => {
      document.addEventListener(O, I);
    }), s.pointerPeekCount = 0), s.pointerPeekCount++;
    const S = {
      pointerId: p.pointerId,
      id: f,
      eventTarget: p.currentTarget
    };
    s.pointers.set(p.pointerId, S), i.emit("edge:pointerdown", we(f, p));
  }
  function l(f) {
    var z, T;
    f.stopPropagation();
    const p = s.pointers.get(f.pointerId);
    if (!p)
      return;
    s.pointers.delete(f.pointerId);
    const S = p.id;
    i.emit("edge:pointerup", we(S, f));
    const [O, I] = Kt(
      s.clicks,
      p.pointerId,
      S instanceof Array ? S.join(",") : S,
      f
    );
    (z = p.eventTarget) == null || z.dispatchEvent(O), I && ((T = p.eventTarget) == null || T.dispatchEvent(I)), s.pointers.size === 0 && (s.pointerPeekCount = 0, he(r).forEach(([A, R]) => {
      document.removeEventListener(A, R);
    }), Yt(s.clicks), t.viewMode.value = "default");
  }
  function u(f) {
    if (f.stopPropagation(), !!s.pointers.get(f.pointerId)) {
      for (const S of s.pointers.values()) {
        const O = S.id;
        i.emit("edge:pointerup", we(O, f));
      }
      s.pointers.clear(), s.pointerPeekCount = 0, he(r).forEach(([S, O]) => {
        document.removeEventListener(S, O);
      }), i.emit("view:mode", "default");
    }
  }
  function c(f, p) {
    var I;
    if (p.isTrusted || p.shiftKey && !["container", "edge"].includes(t.selectionMode.value))
      return;
    t.selectionMode.value = "edge";
    const S = f instanceof Array ? f : [f], O = Qe.valueOf(s.pointers).filter((z) => (z.id instanceof Array ? z.id : [z.id]).every((A) => o.has(A))).length > 0;
    if (f instanceof Array)
      S.find((T) => {
        var A;
        return (A = e[T]) == null ? void 0 : A.selectable;
      }) && (p.shiftKey || O ? S.some((T) => o.has(T)) ? S.forEach((T) => o.delete(T)) : S.forEach((T) => {
        var R;
        const A = (R = e[T]) == null ? void 0 : R.selectable;
        typeof A == "number" && o.size >= A || o.add(T);
      }) : (o.clear(), S.forEach((T) => o.add(T))));
    else {
      const z = (I = e[f]) == null ? void 0 : I.selectable;
      z && (p.shiftKey || O ? o.has(f) ? o.delete(f) : typeof z == "number" && o.size >= z || o.add(f) : o.has(f) || (o.clear(), o.add(f)));
    }
    i.emit("edge:click", we(f, p));
  }
  function d(f, p) {
    p.isTrusted || i.emit("edge:dblclick", we(f, p));
  }
  function h(f, p) {
    n.add(f), i.emit("edge:pointerover", we(f, p));
  }
  function v(f, p) {
    n.delete(f), i.emit("edge:pointerout", we(f, p));
  }
  function E(f, p) {
    p.stopPropagation(), i.emit("edge:contextmenu", we(f, p));
  }
  function x(f, p) {
    if (p.button == 2 || (p.stopPropagation(), !["default", "edge"].includes(t.viewMode.value)))
      return;
    s.pointers.size == 0 && (t.viewMode.value = "edge", he(r).forEach(([O, I]) => {
      document.addEventListener(O, I);
    }), s.pointerPeekCount = 0), s.pointerPeekCount++;
    const S = {
      pointerId: p.pointerId,
      id: f,
      eventTarget: p.currentTarget
    };
    s.pointers.set(p.pointerId, S), i.emit("edge:pointerdown", we(f, p));
  }
  function w(f, p) {
    f.forEach((S) => n.add(S)), i.emit("edge:pointerover", we(f, p));
  }
  function g(f, p) {
    f.forEach((S) => n.delete(S)), i.emit("edge:pointerout", we(f, p));
  }
  function y(f, p) {
    c(f, p);
  }
  function k(f, p) {
    d(f, p);
  }
  function m(f, p) {
    p.stopPropagation(), i.emit("edge:contextmenu", we(f, p));
  }
  return {
    handleEdgePointerDownEvent: a,
    handleEdgePointerOverEvent: h,
    handleEdgePointerOutEvent: v,
    handleEdgeClickEvent: c,
    handleEdgeDoubleClickEvent: d,
    handleEdgeContextMenu: E,
    handleEdgesPointerDownEvent: x,
    handleEdgesPointerOverEvent: w,
    handleEdgesPointerOutEvent: g,
    handleEdgesClickEvent: y,
    handleEdgesDoubleClickEvent: k,
    handleEdgesContextMenu: m
  };
}
function we(e, t) {
  return e instanceof Array ? {
    edges: e,
    event: t,
    summarized: !0
  } : {
    edge: e,
    edges: [e],
    event: t,
    summarized: !1
  };
}
function Vi(e, t, n, o) {
  const i = {
    moveCounter: 0,
    pointerCounter: 0,
    clickState: void 0
  }, s = {
    pointermove: a,
    pointerup: l,
    pointercancel: l
  };
  function r(v) {
    i.moveCounter = 0, i.pointerCounter === 0 && he(s).forEach(([E, x]) => {
      document.addEventListener(E, x, { passive: !0 });
    }), i.pointerCounter++;
  }
  function a(v) {
    i.moveCounter++;
  }
  function l(v) {
    if (i.pointerCounter--, i.pointerCounter <= 0) {
      i.pointerCounter = 0, he(s).forEach(([x, w]) => {
        document.removeEventListener(x, w);
      });
      const E = ct(v.pointerType);
      if (i.moveCounter <= E) {
        if (v.shiftKey && t.selectionMode.value !== "container")
          return;
        t.selectionMode.value = "container";
        const [x, w, g] = qn(
          i.clickState,
          v,
          "view"
        );
        i.clickState = x, e.value.dispatchEvent(w), g && e.value.dispatchEvent(g);
      }
    }
  }
  function u(v) {
    v.isTrusted || (v.stopPropagation(), o.emit("view:click", { event: v }));
  }
  function c(v) {
    v.isTrusted || (v.stopPropagation(), o.emit("view:dblclick", { event: v }));
  }
  function d(v) {
    o.emit("view:contextmenu", { event: v }), i.pointerCounter > 0 && (i.pointerCounter = 0, he(s).forEach(([E, x]) => {
      var w;
      (w = e.value) == null || w.removeEventListener(E, x);
    }));
  }
  const h = (v) => {
    v.preventDefault();
  };
  Ue(() => {
    const v = e.value;
    v && (v.addEventListener("pointerdown", r, { passive: !0 }), v.addEventListener("click", u, { passive: !1 }), v.addEventListener("dblclick", c, { passive: !1 }), v.addEventListener("contextmenu", d, { passive: !1 }), n.value && v.addEventListener("wheel", h, { passive: !1 }));
  }), tt(() => {
    const v = e.value;
    v && (v.removeEventListener("pointerdown", r), v.removeEventListener("click", u), v.removeEventListener("dblclick", c), v.removeEventListener("contextmenu", d), n.value && v.removeEventListener("wheel", h));
  }), U(n, (v, E) => {
    const x = e.value;
    !x || v === E || (v ? x.addEventListener("wheel", h, { passive: !1 }) : x.removeEventListener("wheel", h));
  });
}
function Wi(e, t, n, o, i, s) {
  const r = {
    pointers: /* @__PURE__ */ new Map(),
    // <PointerId, ...>
    pointerPeekCount: 0,
    clicks: /* @__PURE__ */ new Map()
  };
  function a(g, y) {
    var k, m;
    return i.value ? { path: (m = (k = e[g]) == null ? void 0 : k.path) != null ? m : g, event: y } : { path: g, event: y };
  }
  const l = {
    pointerup: c,
    pointercancel: d
  };
  U(o, (g) => {
    g.size > 0 && t.selectionMode.value !== "path" ? t.selectionMode.value = "path" : g.size === 0 && t.selectionMode.value === "path" && (t.selectionMode.value = "container");
  }), U(t.selectionMode, (g) => {
    g !== "path" && o.clear();
  });
  function u(g, y) {
    var m;
    if (!((m = e[g]) != null && m.clickable) || y.button == 2 || (y.stopPropagation(), !["default", "path"].includes(t.viewMode.value)))
      return;
    r.pointers.size == 0 && (t.viewMode.value = "path", he(l).forEach(([f, p]) => {
      document.addEventListener(f, p);
    }), r.pointerPeekCount = 0), r.pointerPeekCount++;
    const k = {
      pointerId: y.pointerId,
      id: g,
      eventTarget: y.currentTarget
    };
    r.pointers.set(y.pointerId, k), s.emit("path:pointerdown", a(g, y));
  }
  function c(g) {
    var p, S;
    const y = r.pointers.get(g.pointerId);
    if (!y)
      return;
    g.stopPropagation(), r.pointers.delete(g.pointerId);
    const k = y.id;
    s.emit("path:pointerup", a(k, g));
    const [m, f] = Kt(
      r.clicks,
      y.pointerId,
      k,
      g
    );
    (p = y.eventTarget) == null || p.dispatchEvent(m), f && ((S = y.eventTarget) == null || S.dispatchEvent(f)), r.pointers.size === 0 && (r.pointerPeekCount = 0, he(l).forEach(([O, I]) => {
      document.removeEventListener(O, I);
    }), Yt(r.clicks), t.viewMode.value = "default");
  }
  function d(g) {
    if (r.pointers.get(g.pointerId)) {
      g.stopPropagation();
      for (const k of r.pointers.values()) {
        const m = k.id;
        s.emit("path:pointerup", a(m, g));
      }
      r.pointers.clear(), r.pointerPeekCount = 0, he(l).forEach(([k, m]) => {
        document.removeEventListener(k, m);
      }), s.emit("view:mode", "default");
    }
  }
  function h(g, y) {
    var k;
    (k = e[g]) != null && k.hoverable && (n.add(g), s.emit("path:pointerover", a(g, y)));
  }
  function v(g, y) {
    var k;
    (k = e[g]) != null && k.hoverable && (n.delete(g), s.emit("path:pointerout", a(g, y)));
  }
  function E(g, y) {
    var m, f, p;
    if (y.isTrusted || !((m = e[g]) != null && m.clickable) || y.shiftKey && !["container", "path"].includes(t.selectionMode.value))
      return;
    t.selectionMode.value = "path";
    const k = (p = (f = e[g]) == null ? void 0 : f.selectable) != null ? p : !1;
    if (k) {
      const S = Qe.valueOf(r.pointers).filter((O) => o.has(O.id)).length > 0;
      y.shiftKey || S ? o.has(g) ? o.delete(g) : typeof k == "number" && o.size >= k || o.add(g) : o.has(g) || (o.clear(), o.add(g));
    }
    s.emit("path:click", a(g, y));
  }
  function x(g, y) {
    var k;
    y.isTrusted || (k = e[g]) != null && k.clickable && s.emit("path:dblclick", a(g, y));
  }
  function w(g, y) {
    var k;
    (k = e[g]) != null && k.clickable && (y.stopPropagation(), s.emit("path:contextmenu", a(g, y)));
  }
  return {
    handlePathPointerDownEvent: u,
    handlePathPointerOverEvent: h,
    handlePathPointerOutEvent: v,
    handlePathClickEvent: E,
    handlePathDoubleClickEvent: x,
    handlePathContextMenu: w
  };
}
function Hi(e) {
  return Ee(this, null, function* () {
    const n = yield (yield fetch(e)).blob();
    return new Promise((o, i) => {
      try {
        const s = new FileReader();
        s.onload = function() {
          o(this.result);
        }, s.readAsDataURL(n);
      } catch (s) {
        i(s);
      }
    });
  });
}
function Dt(e, t, n) {
  var s;
  const o = e.createSVGPoint();
  o.x = n.x, o.y = n.y;
  const i = o.matrixTransform((s = t.getCTM()) == null ? void 0 : s.inverse());
  return { x: i.x, y: i.y };
}
function _i(e, t, n) {
  const o = e.createSVGPoint();
  o.x = n.x, o.y = n.y;
  const i = o.matrixTransform(t.getCTM());
  return { x: i.x, y: i.y };
}
function Gn(e, t, n) {
  var u;
  const o = e.cloneNode(!0), i = t.getBBox(), s = 1 / n, r = {
    x: Math.floor((i.x - 10) * s),
    y: Math.floor((i.y - 10) * s),
    width: Math.ceil((i.width + 20) * s),
    height: Math.ceil((i.height + 20) * s)
  };
  o.setAttribute("width", r.width.toString()), o.setAttribute("height", r.height.toString());
  const a = o.querySelector(".v-ng-viewport");
  a.setAttribute("transform", `translate(${-r.x} ${-r.y}), scale(${s})`), a.removeAttribute("style"), o.setAttribute("viewBox", `0 0 ${r.width} ${r.height}`), o.removeAttribute("style");
  const l = document.createNodeIterator(o, NodeFilter.SHOW_COMMENT);
  for (; l.nextNode(); ) {
    const c = l.referenceNode;
    (u = c.parentNode) == null || u.removeChild(c);
  }
  return o;
}
function Fi(e) {
  return Ee(this, null, function* () {
    let t = !1, n = e.getAttribute("href");
    if (n || (t = !0, n = e.getAttribute("xlink:href")), !(!n || n.startsWith("data:")))
      try {
        const o = yield Hi(n);
        e.setAttribute(t ? "xlink:href" : "href", o);
      } catch (o) {
        console.warn("Image download failed.", n);
        return;
      }
  });
}
function Ui(i, s, r) {
  return Ee(this, arguments, function* (e, t, n, o = {}) {
    const a = Gn(e, t, n);
    if (o.embedImages) {
      const u = Array.from(a.querySelectorAll("image")).map((c) => Fi(c));
      yield Promise.all(u);
    }
    return a;
  });
}
function Xi(e, t, n, o, i, s) {
  const r = C(
    () => !!s.node.selectable && s.view.boxSelectionEnabled
  ), a = C(() => t.viewMode.value === "box-selection"), l = j(), u = j(), c = {
    pointers: /* @__PURE__ */ new Set(),
    // Set of pointers being pressed
    points: /* @__PURE__ */ new Map(),
    // Point indicated by each pointer
    startPoint: null,
    // Point where the drag started
    selectedNodesAtSelectStarted: /* @__PURE__ */ new Set(),
    // Nodes selected at the start of the selection
    selectionType: "append",
    // Selection method for nodes included in the dragged range
    options: {
      // options specified by user at start of selection mode
      stopTrigger: "pointerup",
      selectionType: "append",
      selectionTypeWithShiftKey: "same"
    }
  }, d = _o(
    () => {
      qi(
        q(e.value, "container"),
        q(l.value, "viewport"),
        u,
        n.nodes,
        o,
        i,
        c.selectedNodesAtSelectStarted,
        c.selectionType
      );
    },
    50,
    { maxWait: 100 }
  ), h = new Gi(
    e,
    E,
    x,
    w,
    v,
    g
  );
  function v(p) {
    if (c.options.stopTrigger !== "click" || c.pointers.size > 0) return;
    const S = { x: p.offsetX, y: p.offsetY };
    c.startPoint && V.fromObject(c.startPoint).distance(S) > 10 || f();
  }
  function E(p) {
    p.stopPropagation();
    const S = { x: p.offsetX, y: p.offsetY };
    c.pointers.size === 0 && (c.startPoint = S, h.activate(), c.selectedNodesAtSelectStarted.clear(), i.forEach((O) => c.selectedNodesAtSelectStarted.add(O)), c.options.selectionTypeWithShiftKey === "same" ? c.selectionType = c.options.selectionType : c.selectionType = p.shiftKey ? c.options.selectionTypeWithShiftKey : c.options.selectionType), c.pointers.has(p.pointerId) || c.pointers.add(p.pointerId), c.points.set(p.pointerId, S), y();
  }
  function x(p) {
    if (c.pointers.delete(p.pointerId), c.pointers.size === 1) {
      const S = q(e.value).getBoundingClientRect(), O = { x: p.x - S.x, y: p.y - S.y };
      c.startPoint = O;
    } else c.pointers.size === 0 && (h.deactivate(), c.options.stopTrigger === "pointerup" && f(), c.selectedNodesAtSelectStarted.clear());
    y();
  }
  function w(p) {
    const S = q(e.value).getBoundingClientRect(), O = { x: p.x - S.x, y: p.y - S.y };
    c.points.set(p.pointerId, O), y(), d();
  }
  function g(p) {
    p.key === "Escape" && c.options.stopTrigger !== "manual" && (p.stopPropagation(), f());
  }
  function y() {
    let p, S;
    const O = Array.from(c.pointers);
    if (O.length >= 2) {
      const I = O[0], z = O[O.length - 1];
      p = c.points.get(I), S = c.points.get(z);
    } else if (c.startPoint && O.length === 1) {
      const I = O[0];
      p = c.startPoint, S = c.points.get(I);
    } else
      p = void 0, S = void 0;
    p && S ? (u.value = {
      pos: {
        x: Math.min(p.x, S.x),
        y: Math.min(p.y, S.y)
      },
      size: {
        width: Math.abs(S.x - p.x),
        height: Math.abs(S.y - p.y)
      }
    }, u.value.size.width === 0 && (u.value.size.width = 1), u.value.size.height === 0 && (u.value.size.height = 1)) : u.value && (u.value = void 0);
  }
  const k = new Ki(
    e,
    // key down
    (p) => {
      r.value && s.view.selection.detector(p) && (m({
        stop: "manual",
        type: "append",
        withShiftKey: "invert"
      }), k.activate());
    },
    // key up
    (p) => {
      r.value && s.view.selection.detector(p) && (c.pointers.size === 0 ? f() : c.options.stopTrigger = "pointerup", k.deactivate());
    }
  );
  U(r, (p) => {
    p ? k.register() : k.unregister();
  }), Ue(() => {
    var p;
    l.value = (p = e.value) == null ? void 0 : p.querySelector(".v-ng-viewport"), r.value && k.register();
  }), tt(() => {
    f(), r.value && k.unregister();
  });
  function m(p = {}) {
    var S, O, I;
    c.options = {
      stopTrigger: (S = p.stop) != null ? S : "pointerup",
      selectionType: (O = p.type) != null ? O : "append",
      selectionTypeWithShiftKey: (I = p.withShiftKey) != null ? I : "same"
    }, t.viewMode.value !== "box-selection" && (t.viewMode.value = "box-selection", c.pointers.clear(), h.register());
  }
  function f() {
    t.viewMode.value === "box-selection" && (t.viewMode.value = "default", h.unregister());
  }
  return { isBoxSelectionMode: a, selectionBox: u, startBoxSelection: m, stopBoxSelection: f };
}
function qi(e, t, n, o, i, s, r, a) {
  if (!n.value) return;
  const l = n.value, u = Dt(e, t, l.pos), c = Dt(e, t, {
    x: l.pos.x + l.size.width,
    y: l.pos.y + l.size.height
  }), d = new Set(
    Object.entries(o).filter(([h, v]) => u.x <= v.x && v.x <= c.x && u.y <= v.y && v.y <= c.y).map(([h, v]) => h)
  );
  if (a === "append")
    s.forEach((h) => {
      d.has(h) || s.delete(h);
    }), d.forEach((h) => {
      var E, x;
      const v = (x = (E = i[h]) == null ? void 0 : E.selectable) != null ? x : !1;
      (v === !0 || typeof v == "number" && s.size < v) && s.add(h);
    });
  else {
    const h = new Set(r);
    h.forEach((v) => {
      d.has(v) && h.delete(v);
    }), d.forEach((v) => {
      var E, x;
      if (!r.has(v)) {
        const w = (x = (E = i[v]) == null ? void 0 : E.selectable) != null ? x : !1;
        (w === !0 || typeof w == "number" && h.size < w) && h.add(v);
      }
    }), s.clear(), h.forEach((v) => s.add(v));
  }
}
class Gi {
  constructor(t, n, o, i, s, r) {
    this._container = t, this._handlePointerDownEvent = n, this._handlePointerUpEvent = o, this._handlePointerMoveEvent = i, this._handleClickEvent = s, this._handleKeyDownEvent = r, this._ignoreEvent = (a) => a.stopPropagation();
  }
  register() {
    const t = { capture: !0, passive: !1 }, n = q(this._container.value, "container");
    n.addEventListener("pointerdown", this._handlePointerDownEvent, t), n.addEventListener("click", this._handleClickEvent, t), n.addEventListener("pointerenter", this._ignoreEvent, t), n.addEventListener("pointerleave", this._ignoreEvent, t), document.addEventListener("keydown", this._handleKeyDownEvent, t);
  }
  activate() {
    const t = { capture: !0, passive: !1 };
    document.addEventListener("pointermove", this._handlePointerMoveEvent, t), document.addEventListener("pointerup", this._handlePointerUpEvent, t);
  }
  deactivate() {
    const t = { capture: !0 };
    document.removeEventListener("pointermove", this._handlePointerMoveEvent, t), document.removeEventListener("pointerup", this._handlePointerUpEvent, t);
  }
  unregister() {
    this.deactivate();
    const t = { capture: !0 };
    if (this._container.value) {
      const n = this._container.value;
      n.removeEventListener("pointerdown", this._handlePointerDownEvent, t), n.removeEventListener("click", this._handleClickEvent, t), n.removeEventListener("pointerenter", this._ignoreEvent, t), n.removeEventListener("pointerleave", this._ignoreEvent, t), document.removeEventListener("keydown", this._handleKeyDownEvent, t);
    }
  }
}
class Ki {
  constructor(t, n, o) {
    this._container = t, this._handleKeyDownEvent = n, this._handleKeyUpEvent = o, this._preventDefault = (i) => {
      i.stopPropagation(), i.preventDefault();
    };
  }
  register() {
    document.addEventListener("keydown", this._handleKeyDownEvent, { capture: !0, passive: !0 });
  }
  activate() {
    document.addEventListener("keyup", this._handleKeyUpEvent, { capture: !0, passive: !0 }), q(this._container.value, "container").addEventListener("contextmenu", this._preventDefault, { passive: !1 });
  }
  deactivate() {
    document.removeEventListener("keyup", this._handleKeyUpEvent, { capture: !0 }), this._container.value && this._container.value.removeEventListener("contextmenu", this._preventDefault);
  }
  unregister() {
    this.deactivate(), document.removeEventListener("keydown", this._handleKeyDownEvent, { capture: !0 });
  }
}
const Kn = Symbol("mouseEventHandlers");
function Yi(e, t, n, o, i, s, r, a, l, u, c, d, h, v, E, x) {
  const w = {
    selectionMode: j("container"),
    viewMode: j("default")
  };
  r.size > 0 ? w.selectionMode.value = "node" : a.size > 0 ? w.selectionMode.value = "edge" : l.size > 0 && (w.selectionMode.value = "path"), U(w.viewMode, (y) => {
    x.emit("view:mode", y);
  }), Vi(e, w, v, x);
  const g = se(se(se(se({
    selectedNodes: r,
    hoveredNodes: u,
    selectedEdges: a,
    hoveredEdges: c,
    selectedPaths: l,
    hoveredPaths: d
  }, Bi(
    o,
    t,
    w,
    u,
    r,
    n,
    x
  )), Ri(i, w, c, a, x)), Wi(
    s,
    w,
    d,
    l,
    h,
    x
  )), Xi(
    e,
    w,
    t,
    o,
    r,
    E
  ));
  return Ze(Kn, g), g;
}
function it() {
  return q(De(Kn), "mouseEventHandlers");
}
function Qi(e) {
  return { all: e = e || /* @__PURE__ */ new Map(), on: function(t, n) {
    var o = e.get(t);
    o ? o.push(n) : e.set(t, [n]);
  }, off: function(t, n) {
    var o = e.get(t);
    o && (n ? o.splice(o.indexOf(n) >>> 0, 1) : e.set(t, []));
  }, emit: function(t, n) {
    var o = e.get(t);
    o && o.slice().map(function(i) {
      i(n);
    }), (o = e.get("*")) && o.slice().map(function(i) {
      i(t, n);
    });
  } };
}
const Yn = Symbol("emitter");
function Ji() {
  const e = Qi();
  return Ze(Yn, e), e;
}
function es() {
  return q(De(Yn), "event emitter");
}
var ft = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function ts(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var wt = {
  /**
   * Get global this object
   *
   * @return {Object}        global this object
   */
  getGlobalThis: function() {
    if (typeof globalThis != "undefined") return globalThis;
    if (typeof self != "undefined") return self;
    if (typeof window != "undefined") return window;
    if (typeof ft != "undefined") return ft;
    if (typeof this != "undefined") return this;
    throw new Error("Unable to locate global `this`");
  },
  /**
   * Extends an object
   *
   * @param  {Object} target object to extend
   * @param  {Object} source object to take properties from
   * @return {Object}        extended object
   */
  extend: function(e, t) {
    e = e || {};
    for (var n in t)
      this.isObject(t[n]) ? e[n] = this.extend(e[n], t[n]) : e[n] = t[n];
    return e;
  },
  /**
   * Checks if an object is a DOM element
   *
   * @param  {Object}  o HTML element or String
   * @return {Boolean}   returns true if object is a DOM element
   */
  isElement: function(e) {
    return e instanceof HTMLElement || e instanceof SVGElement || e instanceof SVGSVGElement || //DOM2
    e && typeof e == "object" && e !== null && e.nodeType === 1 && typeof e.nodeName == "string";
  },
  /**
   * Checks if an object is an Object
   *
   * @param  {Object}  o Object
   * @return {Boolean}   returns true if object is an Object
   */
  isObject: function(e) {
    return Object.prototype.toString.call(e) === "[object Object]";
  },
  /**
   * Checks if variable is Number
   *
   * @param  {Integer|Float}  n
   * @return {Boolean}   returns true if variable is Number
   */
  isNumber: function(e) {
    return !isNaN(parseFloat(e)) && isFinite(e);
  },
  /**
   * Search for an SVG element
   *
   * @param  {Object|String} elementOrSelector DOM Element or selector String
   * @return {Object|Null}                   SVG or null
   */
  getSvg: function(e) {
    var t, n;
    if (this.isElement(e))
      t = e;
    else if (typeof e == "string" || e instanceof String) {
      if (t = document.querySelector(e), !t)
        throw new Error(
          "Provided selector did not find any elements. Selector: " + e
        );
    } else
      throw new Error("Provided selector is not an HTML object nor String");
    if (t.tagName.toLowerCase() === "svg")
      n = t;
    else if (t.tagName.toLowerCase() === "object")
      n = t.contentDocument.documentElement;
    else if (t.tagName.toLowerCase() === "embed")
      n = t.getSVGDocument().documentElement;
    else
      throw t.tagName.toLowerCase() === "img" ? new Error(
        'Cannot script an SVG in an "img" element. Please use an "object" element or an in-line SVG.'
      ) : new Error("Cannot get SVG.");
    return n;
  },
  /**
   * Attach a given context to a function
   * @param  {Function} fn      Function
   * @param  {Object}   context Context
   * @return {Function}           Function with certain context
   */
  proxy: function(e, t) {
    return function() {
      return e.apply(t, arguments);
    };
  },
  /**
   * Returns object type
   * Uses toString that returns [object SVGPoint]
   * And than parses object type from string
   *
   * @param  {Object} o Any object
   * @return {String}   Object type
   */
  getType: function(e) {
    return Object.prototype.toString.apply(e).replace(/^\[object\s/, "").replace(/\]$/, "");
  },
  /**
   * If it is a touch event than add clientX and clientY to event object
   *
   * @param  {Event} evt
   * @param  {SVGSVGElement} svg
   */
  mouseAndTouchNormalize: function(e, t) {
    if (e.clientX === void 0 || e.clientX === null)
      if (e.clientX = 0, e.clientY = 0, e.touches !== void 0 && e.touches.length) {
        if (e.touches[0].clientX !== void 0)
          e.clientX = e.touches[0].clientX, e.clientY = e.touches[0].clientY;
        else if (e.touches[0].pageX !== void 0) {
          var n = t.getBoundingClientRect();
          e.clientX = e.touches[0].pageX - n.left, e.clientY = e.touches[0].pageY - n.top;
        }
      } else e.originalEvent !== void 0 && e.originalEvent.clientX !== void 0 && (e.clientX = e.originalEvent.clientX, e.clientY = e.originalEvent.clientY);
  },
  /**
   * If it is a touch event than add clientX and clientY to event object
   *
   * @param  {Event} evt
   * @param  {SVGSVGElement} svg
   * @param  {Number} touch
   */
  touchNormalize: function(e, t, n) {
    if (e.touches !== void 0 && e.touches.length) {
      if (e.touches[n].clientX !== void 0)
        e.clientX = e.touches[n].clientX, e.clientY = e.touches[n].clientY;
      else if (e.touches[n].pageX !== void 0) {
        var o = t.getBoundingClientRect();
        e.clientX = e.touches[n].pageX - o.left, e.clientY = e.touches[n].pageY - o.top;
      }
    } else
      (e.clientX === void 0 || e.clientX === null) && (e.clientX = 0, e.clientY = 0, e.originalEvent !== void 0 && e.originalEvent.clientX !== void 0 && (e.clientX = e.originalEvent.clientX, e.clientY = e.originalEvent.clientY));
  },
  /**
   * Check if an event is a double click/tap
   * TODO: For touch gestures use a library (hammer.js) that takes in account other events
   * (touchmove and touchend). It should take in account tap duration and traveled distance
   *
   * @param  {Event}  evt
   * @param  {Event}  prevEvt Previous Event
   * @return {Boolean}
   */
  isDblClick: function(e, t) {
    if (e.detail === 2)
      return !0;
    if (t != null) {
      var n = e.timeStamp - t.timeStamp, o = Math.sqrt(
        Math.pow(e.clientX - t.clientX, 2) + Math.pow(e.clientY - t.clientY, 2)
      );
      return n < 250 && o < 10;
    }
    return !1;
  },
  /**
   * Returns current timestamp as an integer
   *
   * @return {Number}
   */
  now: Date.now || function() {
    return (/* @__PURE__ */ new Date()).getTime();
  },
  // From underscore.
  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  throttle: function(e, t, n) {
    var o = this, i, s, r, a = null, l = 0;
    n || (n = {});
    var u = function() {
      l = n.leading === !1 ? 0 : o.now(), a = null, r = e.apply(i, s), a || (i = s = null);
    };
    return function() {
      var c = o.now();
      !l && n.leading === !1 && (l = c);
      var d = t - (c - l);
      return i = this, s = arguments, d <= 0 || d > t ? (clearTimeout(a), a = null, l = c, r = e.apply(i, s), a || (i = s = null)) : !a && n.trailing !== !1 && (a = setTimeout(u, d)), r;
    };
  },
  /**
   * Create a requestAnimationFrame simulation
   *
   * @param  {Number|String} refreshRate
   * @return {Function}
   */
  createRequestAnimationFrame: function(e) {
    var t = null;
    return e !== "auto" && e < 60 && e > 1 && (t = Math.floor(1e3 / e)), t === null ? window.requestAnimationFrame || kn(33) : kn(t);
  },
  /**
   * Calculate distance of points
   *
   * @param  {SVGPoint} point1
   * @param  {SVGPoint} point2
   * @return {Number}
   */
  calculateDistance: function(e, t) {
    var n = e.x - t.x, o = e.y - t.y;
    return Math.sqrt(n * n + o * o);
  }
};
function kn(e) {
  return function(t) {
    window.setTimeout(t, e);
  };
}
var ns = wt, os = function() {
  var e = "", t, n, o, i = [], s = { passive: !0 }, r = { passive: !1 };
  ns.getGlobalThis().addEventListener ? (t = "addEventListener", n = "removeEventListener") : (t = "attachEvent", n = "detachEvent", e = "on");
  function a() {
    return o || (o = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll"), o;
  }
  function l(x, w) {
    var g = function(y) {
      !y && (y = window.event);
      var k = {
        // keep a ref to the original event object
        originalEvent: y,
        target: y.target || y.srcElement,
        type: "wheel",
        deltaMode: y.type == "MozMousePixelScroll" ? 0 : 1,
        deltaX: 0,
        delatZ: 0,
        preventDefault: function() {
          y.preventDefault ? y.preventDefault() : y.returnValue = !1;
        }
      };
      return a() == "mousewheel" ? (k.deltaY = -0.025 * y.wheelDelta, y.wheelDeltaX && (k.deltaX = -0.025 * y.wheelDeltaX)) : k.deltaY = y.detail, w(k);
    };
    return i.push({
      element: x,
      fn: g
    }), g;
  }
  function u(x) {
    for (var w = 0; w < i.length; w++)
      if (i[w].element === x)
        return i[w].fn;
    return function() {
    };
  }
  function c(x) {
    for (var w = 0; w < i.length; w++)
      if (i[w].element === x)
        return i.splice(w, 1);
  }
  function d(x, w, g, y) {
    var k;
    a() === "wheel" ? k = g : k = l(x, g), x[t](
      e + w,
      k,
      y ? s : r
    );
  }
  function h(x, w, g, y) {
    var k;
    a() === "wheel" ? k = g : k = u(x), x[n](
      e + w,
      k,
      y ? s : r
    ), c(x);
  }
  function v(x, w, g) {
    d(x, a(), w, g), a() == "DOMMouseScroll" && d(
      x,
      "MozMousePixelScroll",
      w,
      g
    );
  }
  function E(x, w, g) {
    h(x, a(), w, g), a() == "DOMMouseScroll" && h(
      x,
      "MozMousePixelScroll",
      w,
      g
    );
  }
  return {
    on: v,
    off: E
  };
}(), at = wt, Qn = "unknown";
/*@cc_on!@*/
typeof document != "undefined" && document.documentMode && (Qn = "ie");
var Qt = {
  svgNS: "http://www.w3.org/2000/svg",
  xmlNS: "http://www.w3.org/XML/1998/namespace",
  xmlnsNS: "http://www.w3.org/2000/xmlns/",
  xlinkNS: "http://www.w3.org/1999/xlink",
  evNS: "http://www.w3.org/2001/xml-events",
  /**
   * Get svg dimensions: width and height
   *
   * @param  {SVGSVGElement} svg
   * @return {Object}     {width: 0, height: 0}
   */
  getBoundingClientRectNormalized: function(e) {
    if (e.clientWidth && e.clientHeight)
      return { width: e.clientWidth, height: e.clientHeight };
    if (e.getBoundingClientRect())
      return e.getBoundingClientRect();
    throw new Error("Cannot get BoundingClientRect for SVG.");
  },
  /**
   * Gets g element with class of "viewport" or creates it if it doesn't exist
   *
   * @param  {SVGSVGElement} svg
   * @return {SVGElement}     g (group) element
   */
  getOrCreateViewport: function(e, t) {
    var n = null;
    if (at.isElement(t) ? n = t : n = e.querySelector(t), !n) {
      var o = Array.prototype.slice.call(e.childNodes || e.children).filter(function(l) {
        return l.nodeName !== "defs" && l.nodeName !== "#text";
      });
      o.length === 1 && o[0].nodeName === "g" && o[0].getAttribute("transform") === null && (n = o[0]);
    }
    if (!n) {
      var i = "viewport-" + (/* @__PURE__ */ new Date()).toISOString().replace(/\D/g, "");
      n = document.createElementNS(this.svgNS, "g"), n.setAttribute("id", i);
      var s = e.childNodes || e.children;
      if (s && s.length > 0)
        for (var r = s.length; r > 0; r--)
          s[s.length - r].nodeName !== "defs" && n.appendChild(s[s.length - r]);
      e.appendChild(n);
    }
    var a = [];
    return n.getAttribute("class") && (a = n.getAttribute("class").split(" ")), ~a.indexOf("svg-pan-zoom_viewport") || (a.push("svg-pan-zoom_viewport"), n.setAttribute("class", a.join(" "))), n;
  },
  /**
   * Set SVG attributes
   *
   * @param  {SVGSVGElement} svg
   */
  setupSvgAttributes: function(e) {
    if (e.setAttribute("xmlns", this.svgNS), e.setAttributeNS(this.xmlnsNS, "xmlns:xlink", this.xlinkNS), e.setAttributeNS(this.xmlnsNS, "xmlns:ev", this.evNS), e.parentNode !== null) {
      var t = e.getAttribute("style") || "";
      t.toLowerCase().indexOf("overflow") === -1 && e.setAttribute("style", "overflow: hidden; " + t);
    }
  },
  /**
   * How long Internet Explorer takes to finish updating its display (ms).
   */
  internetExplorerRedisplayInterval: 300,
  /**
   * Forces the browser to redisplay all SVG elements that rely on an
   * element defined in a 'defs' section. It works globally, for every
   * available defs element on the page.
   * The throttling is intentionally global.
   *
   * This is only needed for IE. It is as a hack to make markers (and 'use' elements?)
   * visible after pan/zoom when there are multiple SVGs on the page.
   * See bug report: https://connect.microsoft.com/IE/feedback/details/781964/
   * also see svg-pan-zoom issue: https://github.com/ariutta/svg-pan-zoom/issues/62
   */
  refreshDefsGlobal: at.throttle(
    function() {
      for (var e = document.querySelectorAll("defs"), t = e.length, n = 0; n < t; n++) {
        var o = e[n];
        o.parentNode.insertBefore(o, o);
      }
    },
    ft ? ft.internetExplorerRedisplayInterval : null
  ),
  /**
   * Sets the current transform matrix of an element
   *
   * @param {SVGElement} element
   * @param {SVGMatrix} matrix  CTM
   * @param {SVGElement} defs
   */
  setCTM: function(e, t, n) {
    var o = this, i = "matrix(" + t.a + "," + t.b + "," + t.c + "," + t.d + "," + t.e + "," + t.f + ")";
    e.setAttributeNS(null, "transform", i), "transform" in e.style ? e.style.transform = i : "-ms-transform" in e.style ? e.style["-ms-transform"] = i : "-webkit-transform" in e.style && (e.style["-webkit-transform"] = i), Qn === "ie" && n && (n.parentNode.insertBefore(n, n), window.setTimeout(function() {
      o.refreshDefsGlobal();
    }, o.internetExplorerRedisplayInterval));
  },
  /**
   * Instantiate an SVGPoint object with given event coordinates
   *
   * @param {Event} evt
   * @param  {SVGSVGElement} svg
   * @return {SVGPoint}     point
   */
  getEventPoint: function(e, t) {
    var n = t.createSVGPoint();
    return at.mouseAndTouchNormalize(e, t), n.x = e.clientX, n.y = e.clientY, n;
  },
  /**
   * Instantiate an SVGPoint object with given touch event coordinates
   *
   * @param {Event} evt
   * @param  {SVGSVGElement} svg
   * @param  {Number} touch
   * @return {SVGPoint}     point
   */
  getTouchPoint: function(e, t, n) {
    var o = t.createSVGPoint();
    return at.touchNormalize(e, t, n), o.x = e.clientX, o.y = e.clientY, o;
  },
  /**
   * Get SVG center point
   *
   * @param  {SVGSVGElement} svg
   * @return {SVGPoint}
   */
  getSvgCenterPoint: function(e, t, n) {
    return this.createSVGPoint(e, t / 2, n / 2);
  },
  /**
   * Create a SVGPoint with given x and y
   *
   * @param  {SVGSVGElement} svg
   * @param  {Number} x
   * @param  {Number} y
   * @return {SVGPoint}
   */
  createSVGPoint: function(e, t, n) {
    var o = e.createSVGPoint();
    return o.x = t, o.y = n, o;
  }
}, pe = Qt, is = {
  enable: function(e) {
    var t = e.svg.querySelector("defs");
    t || (t = document.createElementNS(pe.svgNS, "defs"), e.svg.appendChild(t));
    var n = t.querySelector("style#svg-pan-zoom-controls-styles");
    if (!n) {
      var o = document.createElementNS(pe.svgNS, "style");
      o.setAttribute("id", "svg-pan-zoom-controls-styles"), o.setAttribute("type", "text/css"), o.textContent = ".svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }", t.appendChild(o);
    }
    var i = document.createElementNS(pe.svgNS, "g");
    i.setAttribute("id", "svg-pan-zoom-controls"), i.setAttribute(
      "transform",
      "translate(" + (e.width - 70) + " " + (e.height - 76) + ") scale(0.75)"
    ), i.setAttribute("class", "svg-pan-zoom-control"), i.appendChild(this._createZoomIn(e)), i.appendChild(this._createZoomReset(e)), i.appendChild(this._createZoomOut(e)), e.svg.appendChild(i), e.controlIcons = i;
  },
  _createZoomIn: function(e) {
    var t = document.createElementNS(pe.svgNS, "g");
    t.setAttribute("id", "svg-pan-zoom-zoom-in"), t.setAttribute("transform", "translate(30.5 5) scale(0.015)"), t.setAttribute("class", "svg-pan-zoom-control"), t.addEventListener(
      "click",
      function() {
        e.getPublicInstance().zoomIn();
      },
      !1
    ), t.addEventListener(
      "touchstart",
      function() {
        e.getPublicInstance().zoomIn();
      },
      !1
    );
    var n = document.createElementNS(pe.svgNS, "rect");
    n.setAttribute("x", "0"), n.setAttribute("y", "0"), n.setAttribute("width", "1500"), n.setAttribute("height", "1400"), n.setAttribute("class", "svg-pan-zoom-control-background"), t.appendChild(n);
    var o = document.createElementNS(pe.svgNS, "path");
    return o.setAttribute(
      "d",
      "M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z"
    ), o.setAttribute("class", "svg-pan-zoom-control-element"), t.appendChild(o), t;
  },
  _createZoomReset: function(e) {
    var t = document.createElementNS(pe.svgNS, "g");
    t.setAttribute("id", "svg-pan-zoom-reset-pan-zoom"), t.setAttribute("transform", "translate(5 35) scale(0.4)"), t.setAttribute("class", "svg-pan-zoom-control"), t.addEventListener(
      "click",
      function() {
        e.getPublicInstance().reset();
      },
      !1
    ), t.addEventListener(
      "touchstart",
      function() {
        e.getPublicInstance().reset();
      },
      !1
    );
    var n = document.createElementNS(
      pe.svgNS,
      "rect"
    );
    n.setAttribute("x", "2"), n.setAttribute("y", "2"), n.setAttribute("width", "182"), n.setAttribute("height", "58"), n.setAttribute(
      "class",
      "svg-pan-zoom-control-background"
    ), t.appendChild(n);
    var o = document.createElementNS(
      pe.svgNS,
      "path"
    );
    o.setAttribute(
      "d",
      "M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z"
    ), o.setAttribute(
      "class",
      "svg-pan-zoom-control-element"
    ), t.appendChild(o);
    var i = document.createElementNS(
      pe.svgNS,
      "path"
    );
    return i.setAttribute(
      "d",
      "M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z"
    ), i.setAttribute(
      "class",
      "svg-pan-zoom-control-element"
    ), t.appendChild(i), t;
  },
  _createZoomOut: function(e) {
    var t = document.createElementNS(pe.svgNS, "g");
    t.setAttribute("id", "svg-pan-zoom-zoom-out"), t.setAttribute("transform", "translate(30.5 70) scale(0.015)"), t.setAttribute("class", "svg-pan-zoom-control"), t.addEventListener(
      "click",
      function() {
        e.getPublicInstance().zoomOut();
      },
      !1
    ), t.addEventListener(
      "touchstart",
      function() {
        e.getPublicInstance().zoomOut();
      },
      !1
    );
    var n = document.createElementNS(pe.svgNS, "rect");
    n.setAttribute("x", "0"), n.setAttribute("y", "0"), n.setAttribute("width", "1500"), n.setAttribute("height", "1400"), n.setAttribute("class", "svg-pan-zoom-control-background"), t.appendChild(n);
    var o = document.createElementNS(pe.svgNS, "path");
    return o.setAttribute(
      "d",
      "M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z"
    ), o.setAttribute("class", "svg-pan-zoom-control-element"), t.appendChild(o), t;
  },
  disable: function(e) {
    e.controlIcons && (e.controlIcons.parentNode.removeChild(e.controlIcons), e.controlIcons = null);
  }
}, ss = Qt, Ae = wt, oe = function(e, t) {
  this.init(e, t);
};
oe.prototype.init = function(e, t) {
  this.viewport = e, this.options = t, this.originalState = { zoom: 1, x: 0, y: 0 }, this.activeState = { zoom: 1, x: 0, y: 0 }, this.updateCTMCached = Ae.proxy(this.updateCTM, this), this.requestAnimationFrame = Ae.createRequestAnimationFrame(
    this.options.refreshRate
  ), this.viewBox = { x: 0, y: 0, width: 0, height: 0 }, this.cacheViewBox();
  var n = this.processCTM();
  this.setCTM(n), this.updateCTM();
};
oe.prototype.cacheViewBox = function() {
  var e = this.options.svg.getAttribute("viewBox");
  if (e) {
    var t = e.split(/[\s\,]/).filter(function(o) {
      return o;
    }).map(parseFloat);
    this.viewBox.x = t[0], this.viewBox.y = t[1], this.viewBox.width = t[2], this.viewBox.height = t[3];
    var n = Math.min(
      this.options.width / this.viewBox.width,
      this.options.height / this.viewBox.height
    );
    this.activeState.zoom = isFinite(n) ? n : 1, this.activeState.x = (this.options.width - this.viewBox.width * n) / 2, this.activeState.y = (this.options.height - this.viewBox.height * n) / 2, this.updateCTMOnNextFrame(), this.options.svg.removeAttribute("viewBox");
  } else
    this.simpleViewBoxCache();
};
oe.prototype.simpleViewBoxCache = function() {
  var e = this.viewport.getBBox();
  this.viewBox.x = e.x, this.viewBox.y = e.y, this.viewBox.width = e.width, this.viewBox.height = e.height;
};
oe.prototype.getViewBox = function() {
  return Ae.extend({}, this.viewBox);
};
oe.prototype.processCTM = function() {
  var e = this.getCTM();
  if (this.options.fit || this.options.contain) {
    var t;
    this.options.fit ? t = Math.min(
      this.options.width / this.viewBox.width,
      this.options.height / this.viewBox.height
    ) : t = Math.max(
      this.options.width / this.viewBox.width,
      this.options.height / this.viewBox.height
    ), t = isFinite(t) ? t : 1, e.a = t, e.d = t, e.e = -this.viewBox.x * t, e.f = -this.viewBox.y * t;
  }
  if (this.options.center) {
    var n = (this.options.width - (this.viewBox.width + this.viewBox.x * 2) * e.a) * 0.5, o = (this.options.height - (this.viewBox.height + this.viewBox.y * 2) * e.a) * 0.5;
    e.e = n, e.f = o;
  }
  return this.originalState.zoom = e.a, this.originalState.x = e.e, this.originalState.y = e.f, e;
};
oe.prototype.getOriginalState = function() {
  return Ae.extend({}, this.originalState);
};
oe.prototype.getState = function() {
  return Ae.extend({}, this.activeState);
};
oe.prototype.getZoom = function() {
  return this.activeState.zoom;
};
oe.prototype.getRelativeZoom = function() {
  return this.activeState.zoom / this.originalState.zoom;
};
oe.prototype.computeRelativeZoom = function(e) {
  return e / this.originalState.zoom;
};
oe.prototype.getPan = function() {
  return { x: this.activeState.x, y: this.activeState.y };
};
oe.prototype.getCTM = function() {
  var e = this.options.svg.createSVGMatrix();
  return e.a = this.activeState.zoom, e.b = 0, e.c = 0, e.d = this.activeState.zoom, e.e = this.activeState.x, e.f = this.activeState.y, e;
};
oe.prototype.setCTM = function(e) {
  var t = this.isZoomDifferent(e), n = this.isPanDifferent(e);
  if (t || n) {
    if (t && (this.options.beforeZoom(
      this.getRelativeZoom(),
      this.computeRelativeZoom(e.a)
    ) === !1 ? (e.a = e.d = this.activeState.zoom, t = !1) : (this.updateCache(e), this.options.onZoom(this.getRelativeZoom()))), n) {
      var o = this.options.beforePan(this.getPan(), {
        x: e.e,
        y: e.f
      }), i = !1, s = !1;
      o === !1 ? (e.e = this.getPan().x, e.f = this.getPan().y, i = s = !0) : Ae.isObject(o) && (o.x === !1 ? (e.e = this.getPan().x, i = !0) : Ae.isNumber(o.x) && (e.e = o.x), o.y === !1 ? (e.f = this.getPan().y, s = !0) : Ae.isNumber(o.y) && (e.f = o.y)), i && s || !this.isPanDifferent(e) ? n = !1 : (this.updateCache(e), this.options.onPan(this.getPan()));
    }
    (t || n) && this.updateCTMOnNextFrame();
  }
};
oe.prototype.isZoomDifferent = function(e) {
  return this.activeState.zoom !== e.a;
};
oe.prototype.isPanDifferent = function(e) {
  return this.activeState.x !== e.e || this.activeState.y !== e.f;
};
oe.prototype.updateCache = function(e) {
  this.activeState.zoom = e.a, this.activeState.x = e.e, this.activeState.y = e.f;
};
oe.prototype.pendingUpdate = !1;
oe.prototype.updateCTMOnNextFrame = function() {
  this.pendingUpdate || (this.pendingUpdate = !0, this.requestAnimationFrame.call(window, this.updateCTMCached));
};
oe.prototype.updateCTM = function() {
  var e = this.getCTM();
  ss.setCTM(this.viewport, e, this.defs), this.pendingUpdate = !1, this.options.onUpdatedCTM && this.options.onUpdatedCTM(e);
};
var rs = function(e, t) {
  return new oe(e, t);
}, Jn = os, Nt = is, fe = wt, re = Qt, as = rs, X = function(e, t) {
  this.init(e, t);
}, ls = {
  viewportSelector: ".svg-pan-zoom_viewport",
  // Viewport selector. Can be querySelector string or SVGElement
  panEnabled: !0,
  // enable or disable panning (default enabled)
  controlIconsEnabled: !1,
  // insert icons to give user an option in addition to mouse events to control pan/zoom (default disabled)
  zoomEnabled: !0,
  // enable or disable zooming (default enabled)
  dblClickZoomEnabled: !0,
  // enable or disable zooming by double clicking (default enabled)
  mouseWheelZoomEnabled: !0,
  // enable or disable zooming by mouse wheel (default enabled)
  preventMouseEventsDefault: !0,
  // enable or disable preventDefault for mouse events
  zoomScaleSensitivity: 0.1,
  // Zoom sensitivity
  minZoom: 0.5,
  // Minimum Zoom level
  maxZoom: 10,
  // Maximum Zoom level
  fit: !0,
  // enable or disable viewport fit in SVG (default true)
  contain: !1,
  // enable or disable viewport contain the svg (default false)
  center: !0,
  // enable or disable viewport centering in SVG (default true)
  refreshRate: "auto",
  // Maximum number of frames per second (altering SVG's viewport)
  beforeZoom: null,
  onZoom: null,
  beforePan: null,
  onPan: null,
  customEventsHandler: null,
  eventsListenerElement: null,
  onUpdatedCTM: null
}, eo = { passive: !0 }, to = { passive: !1 };
X.prototype.init = function(e, t) {
  var n = this;
  this.svg = e, this.defs = e.querySelector("defs"), re.setupSvgAttributes(this.svg), this.options = fe.extend(fe.extend({}, ls), t), this.state = "none";
  var o = re.getBoundingClientRectNormalized(e);
  this.width = o.width, this.height = o.height, this.viewport = as(
    re.getOrCreateViewport(this.svg, this.options.viewportSelector),
    {
      svg: this.svg,
      width: this.width,
      height: this.height,
      fit: this.options.fit,
      contain: this.options.contain,
      center: this.options.center,
      refreshRate: this.options.refreshRate,
      // Put callbacks into functions as they can change through time
      beforeZoom: function(s, r) {
        if (n.viewport && n.options.beforeZoom)
          return n.options.beforeZoom(s, r);
      },
      onZoom: function(s) {
        if (n.viewport && n.options.onZoom)
          return n.options.onZoom(s);
      },
      beforePan: function(s, r) {
        if (n.viewport && n.options.beforePan)
          return n.options.beforePan(s, r);
      },
      onPan: function(s) {
        if (n.viewport && n.options.onPan)
          return n.options.onPan(s);
      },
      onUpdatedCTM: function(s) {
        if (n.viewport && n.options.onUpdatedCTM)
          return n.options.onUpdatedCTM(s);
      }
    }
  );
  var i = this.getPublicInstance();
  i.setBeforeZoom(this.options.beforeZoom), i.setOnZoom(this.options.onZoom), i.setBeforePan(this.options.beforePan), i.setOnPan(this.options.onPan), i.setOnUpdatedCTM(this.options.onUpdatedCTM), this.options.controlIconsEnabled && Nt.enable(this), this.lastMouseWheelEventTime = Date.now(), this.setupHandlers();
};
X.prototype.setupHandlers = function() {
  var e = this, t = null;
  if (this.eventListeners = {
    // Mouse down group
    pointerdown: function(s) {
      if (s.pointerType !== "touch") {
        var r = e.handleMouseDown(s, t);
        return t = s, r;
      }
    },
    touchstart: function(s) {
      var r = e.handleTouchStart(s, t);
      return t = s, r;
    },
    // Mouse up group
    pointerup: function(s) {
      if (s.pointerType !== "touch")
        return e.handleMouseUp(s);
    },
    touchend: function(s) {
      return e.handleTouchEnd(s);
    },
    // Mouse move group
    pointermove: function(s) {
      if (s.pointerType !== "touch")
        return e.handleMouseMove(s);
    },
    touchmove: function(s) {
      return e.handleTouchMove(s);
    },
    // Mouse leave group
    pointerleave: function(s) {
      if (s.pointerType !== "touch")
        return e.handleMouseUp(s);
    },
    pointercancel: function(s) {
      if (s.pointerType !== "touch")
        return e.handleMouseUp(s);
    },
    touchleave: function(s) {
      return e.handleTouchEnd(s);
    },
    touchcancel: function(s) {
      return e.handleTouchEnd(s);
    }
  }, this.options.customEventsHandler != null) {
    this.options.customEventsHandler.init({
      svgElement: this.svg,
      eventsListenerElement: this.options.eventsListenerElement,
      instance: this.getPublicInstance()
    });
    var n = this.options.customEventsHandler.haltEventListeners;
    if (n && n.length)
      for (var o = n.length - 1; o >= 0; o--)
        this.eventListeners.hasOwnProperty(n[o]) && delete this.eventListeners[n[o]];
  }
  for (var i in this.eventListeners)
    (this.options.eventsListenerElement || this.svg).addEventListener(
      i,
      this.eventListeners[i],
      this.options.preventMouseEventsDefault ? to : eo
    );
  this.options.mouseWheelZoomEnabled && (this.options.mouseWheelZoomEnabled = !1, this.enableMouseWheelZoom());
};
X.prototype.enableMouseWheelZoom = function() {
  if (!this.options.mouseWheelZoomEnabled) {
    var e = this;
    this.wheelListener = function(n) {
      return e.handleMouseWheel(n);
    };
    var t = !this.options.preventMouseEventsDefault;
    Jn.on(
      this.options.eventsListenerElement || this.svg,
      this.wheelListener,
      t
    ), this.options.mouseWheelZoomEnabled = !0;
  }
};
X.prototype.disableMouseWheelZoom = function() {
  if (this.options.mouseWheelZoomEnabled) {
    var e = !this.options.preventMouseEventsDefault;
    Jn.off(
      this.options.eventsListenerElement || this.svg,
      this.wheelListener,
      e
    ), this.options.mouseWheelZoomEnabled = !1;
  }
};
X.prototype.handleMouseWheel = function(e) {
  if (!(!this.options.zoomEnabled || this.state !== "none")) {
    this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1);
    var t = e.deltaY || 1, n = Date.now() - this.lastMouseWheelEventTime, o = 3 + Math.max(0, 30 - n);
    this.lastMouseWheelEventTime = Date.now(), "deltaMode" in e && e.deltaMode === 0 && e.wheelDelta && (t = e.deltaY === 0 ? 0 : Math.abs(e.wheelDelta) / e.deltaY), t = -0.3 < t && t < 0.3 ? t : (t > 0 ? 1 : -1) * Math.log(Math.abs(t) + 10) / o;
    var i = this.svg.getScreenCTM().inverse(), s = re.getEventPoint(e, this.svg).matrixTransform(
      i
    ), r = Math.pow(1 + this.options.zoomScaleSensitivity, -1 * t);
    this.zoomAtPoint(r, s);
  }
};
X.prototype.zoomAtPoint = function(e, t, n) {
  var o = this.viewport.getOriginalState();
  n ? (e = Math.max(
    this.options.minZoom * o.zoom,
    Math.min(this.options.maxZoom * o.zoom, e)
  ), e = e / this.getZoom()) : this.getZoom() * e < this.options.minZoom * o.zoom ? e = this.options.minZoom * o.zoom / this.getZoom() : this.getZoom() * e > this.options.maxZoom * o.zoom && (e = this.options.maxZoom * o.zoom / this.getZoom());
  var i = this.viewport.getCTM(), s = t.matrixTransform(i.inverse()), r = this.svg.createSVGMatrix().translate(s.x, s.y).scale(e).translate(-s.x, -s.y), a = i.multiply(r);
  a.a !== i.a && this.viewport.setCTM(a);
};
X.prototype.zoom = function(e, t) {
  this.zoomAtPoint(
    e,
    re.getSvgCenterPoint(this.svg, this.width, this.height),
    t
  );
};
X.prototype.publicZoom = function(e, t) {
  t && (e = this.computeFromRelativeZoom(e)), this.zoom(e, t);
};
X.prototype.publicZoomAtPoint = function(e, t, n) {
  if (n && (e = this.computeFromRelativeZoom(e)), fe.getType(t) !== "SVGPoint")
    if ("x" in t && "y" in t)
      t = re.createSVGPoint(this.svg, t.x, t.y);
    else
      throw new Error("Given point is invalid");
  this.zoomAtPoint(e, t, n);
};
X.prototype.getZoom = function() {
  return this.viewport.getZoom();
};
X.prototype.getRelativeZoom = function() {
  return this.viewport.getRelativeZoom();
};
X.prototype.computeFromRelativeZoom = function(e) {
  return e * this.viewport.getOriginalState().zoom;
};
X.prototype.resetZoom = function() {
  var e = this.viewport.getOriginalState();
  this.zoom(e.zoom, !0);
};
X.prototype.resetPan = function() {
  this.pan(this.viewport.getOriginalState());
};
X.prototype.reset = function() {
  this.resetZoom(), this.resetPan();
};
X.prototype.handleDblClick = function(e) {
  if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.options.controlIconsEnabled) {
    var t = e.target.getAttribute("class") || "";
    if (t.indexOf("svg-pan-zoom-control") > -1)
      return !1;
  }
  var n;
  e.shiftKey ? n = 1 / ((1 + this.options.zoomScaleSensitivity) * 2) : n = (1 + this.options.zoomScaleSensitivity) * 2;
  var o = re.getEventPoint(e, this.svg).matrixTransform(
    this.svg.getScreenCTM().inverse()
  );
  this.zoomAtPoint(n, o);
};
X.prototype.handleMouseDown = function(e, t) {
  this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), fe.mouseAndTouchNormalize(e, this.svg), this.options.dblClickZoomEnabled && fe.isDblClick(e, t) ? this.handleDblClick(e) : (this.state = "pan", this.firstEventCTM = this.viewport.getCTM(), this.stateOrigin = re.getEventPoint(e, this.svg).matrixTransform(
    this.firstEventCTM.inverse()
  ));
};
X.prototype.handleMouseMove = function(e) {
  if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.state === "pan" && this.options.panEnabled) {
    var t = re.getEventPoint(e, this.svg).matrixTransform(
      this.firstEventCTM.inverse()
    ), n = this.firstEventCTM.translate(
      t.x - this.stateOrigin.x,
      t.y - this.stateOrigin.y
    );
    this.viewport.setCTM(n);
  }
};
X.prototype.handleMouseUp = function(e) {
  this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.state === "pan" && (this.state = "none");
};
X.prototype.handleTouchStart = function(e, t) {
  if (e.touches.length == 1)
    this.handleMouseDown(e, t);
  else {
    this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.firstEventCTM = this.viewport.getCTM();
    var n = re.getTouchPoint(e, this.svg, 0), o = re.getTouchPoint(e, this.svg, 1);
    this.firstDistance = fe.calculateDistance(n, o), n.x = (n.x + o.x) / 2, n.y = (n.y + o.y) / 2, this.stateOrigin = n.matrixTransform(this.firstEventCTM.inverse()), this.firstZoomLevel = this.getZoom();
  }
};
X.prototype.handleTouchMove = function(e) {
  if (e.touches.length == 1)
    this.handleMouseMove(e);
  else {
    if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), !this.options.panEnabled && !this.options.zoomEnabled)
      return;
    var t = re.getTouchPoint(e, this.svg, 0), n = re.getTouchPoint(e, this.svg, 1), o = this.svg.createSVGPoint();
    if (o.x = (t.x + n.x) / 2, o.y = (t.y + n.y) / 2, this.state === "pan" && this.options.panEnabled) {
      var i = o.matrixTransform(this.firstEventCTM.inverse()), s = this.firstEventCTM.translate(
        i.x - this.stateOrigin.x,
        i.y - this.stateOrigin.y
      );
      this.viewport.setCTM(s);
    }
    if (this.options.zoomEnabled) {
      var r = fe.calculateDistance(t, n), a = r / this.firstDistance, l = this.svg.getScreenCTM().inverse(), u = o.matrixTransform(l);
      this.zoomAtPoint(this.firstZoomLevel * a, u, !0);
    }
  }
};
X.prototype.handleTouchEnd = function(e) {
  if (e.touches.length == 0)
    this.handleMouseUp(e);
  else if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.firstEventCTM = this.viewport.getCTM(), e.touches.length == 1)
    this.stateOrigin = re.getEventPoint(e, this.svg).matrixTransform(
      this.firstEventCTM.inverse()
    );
  else {
    var t = re.getTouchPoint(e, this.svg, 0), n = re.getTouchPoint(e, this.svg, 1);
    this.firstDistance = fe.calculateDistance(t, n), t.x = (t.x + n.x) / 2, t.y = (t.y + n.y) / 2, this.stateOrigin = t.matrixTransform(this.firstEventCTM.inverse());
  }
};
X.prototype.fit = function() {
  var e = this.viewport.getViewBox(), t = Math.min(
    this.width / e.width,
    this.height / e.height
  );
  this.zoom(t, !0);
};
X.prototype.contain = function() {
  var e = this.viewport.getViewBox(), t = Math.max(
    this.width / e.width,
    this.height / e.height
  );
  this.zoom(t, !0);
};
X.prototype.center = function() {
  var e = this.viewport.getViewBox(), t = (this.width - (e.width + e.x * 2) * this.getZoom()) * 0.5, n = (this.height - (e.height + e.y * 2) * this.getZoom()) * 0.5;
  this.getPublicInstance().pan({ x: t, y: n });
};
X.prototype.updateBBox = function() {
  this.viewport.simpleViewBoxCache();
};
X.prototype.pan = function(e) {
  var t = this.viewport.getCTM();
  t.e = e.x, t.f = e.y, this.viewport.setCTM(t);
};
X.prototype.panBy = function(e) {
  var t = this.viewport.getCTM();
  t.e += e.x, t.f += e.y, this.viewport.setCTM(t);
};
X.prototype.getPan = function() {
  var e = this.viewport.getState();
  return { x: e.x, y: e.y };
};
X.prototype.resize = function() {
  var e = re.getBoundingClientRectNormalized(
    this.svg
  );
  this.width = e.width, this.height = e.height;
  var t = this.viewport;
  t.options.width = this.width, t.options.height = this.height, t.processCTM(), this.options.controlIconsEnabled && (this.getPublicInstance().disableControlIcons(), this.getPublicInstance().enableControlIcons());
};
X.prototype.destroy = function() {
  var e = this;
  this.beforeZoom = null, this.onZoom = null, this.beforePan = null, this.onPan = null, this.onUpdatedCTM = null, this.options.customEventsHandler != null && this.options.customEventsHandler.destroy({
    svgElement: this.svg,
    eventsListenerElement: this.options.eventsListenerElement,
    instance: this.getPublicInstance()
  });
  for (var t in this.eventListeners)
    (this.options.eventsListenerElement || this.svg).removeEventListener(
      t,
      this.eventListeners[t],
      this.options.preventMouseEventsDefault ? to : eo
    );
  this.disableMouseWheelZoom(), this.getPublicInstance().disableControlIcons(), Te = Te.filter(function(n) {
    return n.svg !== e.svg;
  }), delete this.options, delete this.viewport, delete this.publicInstance, delete this.pi, this.getPublicInstance = function() {
    return null;
  };
};
X.prototype.getPublicInstance = function() {
  var e = this;
  return this.publicInstance || (this.publicInstance = this.pi = {
    // Pan
    enablePan: function() {
      return e.options.panEnabled = !0, e.pi;
    },
    disablePan: function() {
      return e.options.panEnabled = !1, e.pi;
    },
    isPanEnabled: function() {
      return !!e.options.panEnabled;
    },
    pan: function(t) {
      return e.pan(t), e.pi;
    },
    panBy: function(t) {
      return e.panBy(t), e.pi;
    },
    getPan: function() {
      return e.getPan();
    },
    // Pan event
    setBeforePan: function(t) {
      return e.options.beforePan = t === null ? null : fe.proxy(t, e.publicInstance), e.pi;
    },
    setOnPan: function(t) {
      return e.options.onPan = t === null ? null : fe.proxy(t, e.publicInstance), e.pi;
    },
    // Zoom and Control Icons
    enableZoom: function() {
      return e.options.zoomEnabled = !0, e.pi;
    },
    disableZoom: function() {
      return e.options.zoomEnabled = !1, e.pi;
    },
    isZoomEnabled: function() {
      return !!e.options.zoomEnabled;
    },
    enableControlIcons: function() {
      return e.options.controlIconsEnabled || (e.options.controlIconsEnabled = !0, Nt.enable(e)), e.pi;
    },
    disableControlIcons: function() {
      return e.options.controlIconsEnabled && (e.options.controlIconsEnabled = !1, Nt.disable(e)), e.pi;
    },
    isControlIconsEnabled: function() {
      return !!e.options.controlIconsEnabled;
    },
    // Double click zoom
    enableDblClickZoom: function() {
      return e.options.dblClickZoomEnabled = !0, e.pi;
    },
    disableDblClickZoom: function() {
      return e.options.dblClickZoomEnabled = !1, e.pi;
    },
    isDblClickZoomEnabled: function() {
      return !!e.options.dblClickZoomEnabled;
    },
    // Mouse wheel zoom
    enableMouseWheelZoom: function() {
      return e.enableMouseWheelZoom(), e.pi;
    },
    disableMouseWheelZoom: function() {
      return e.disableMouseWheelZoom(), e.pi;
    },
    isMouseWheelZoomEnabled: function() {
      return !!e.options.mouseWheelZoomEnabled;
    },
    // Zoom scale and bounds
    setZoomScaleSensitivity: function(t) {
      return e.options.zoomScaleSensitivity = t, e.pi;
    },
    setMinZoom: function(t) {
      return e.options.minZoom = t, e.pi;
    },
    setMaxZoom: function(t) {
      return e.options.maxZoom = t, e.pi;
    },
    // Zoom event
    setBeforeZoom: function(t) {
      return e.options.beforeZoom = t === null ? null : fe.proxy(t, e.publicInstance), e.pi;
    },
    setOnZoom: function(t) {
      return e.options.onZoom = t === null ? null : fe.proxy(t, e.publicInstance), e.pi;
    },
    // Zooming
    zoom: function(t) {
      return e.publicZoom(t, !0), e.pi;
    },
    zoomBy: function(t) {
      return e.publicZoom(t, !1), e.pi;
    },
    zoomAtPoint: function(t, n) {
      return e.publicZoomAtPoint(t, n, !0), e.pi;
    },
    zoomAtPointBy: function(t, n) {
      return e.publicZoomAtPoint(t, n, !1), e.pi;
    },
    zoomIn: function() {
      return this.zoomBy(1 + e.options.zoomScaleSensitivity), e.pi;
    },
    zoomOut: function() {
      return this.zoomBy(1 / (1 + e.options.zoomScaleSensitivity)), e.pi;
    },
    getZoom: function() {
      return e.getRelativeZoom();
    },
    // CTM update
    setOnUpdatedCTM: function(t) {
      return e.options.onUpdatedCTM = t === null ? null : fe.proxy(t, e.publicInstance), e.pi;
    },
    // Reset
    resetZoom: function() {
      return e.resetZoom(), e.pi;
    },
    resetPan: function() {
      return e.resetPan(), e.pi;
    },
    reset: function() {
      return e.reset(), e.pi;
    },
    // Fit, Contain and Center
    fit: function() {
      return e.fit(), e.pi;
    },
    contain: function() {
      return e.contain(), e.pi;
    },
    center: function() {
      return e.center(), e.pi;
    },
    // Size and Resize
    updateBBox: function() {
      return e.updateBBox(), e.pi;
    },
    resize: function() {
      return e.resize(), e.pi;
    },
    getSizes: function() {
      return {
        width: e.width,
        height: e.height,
        realZoom: e.getZoom(),
        viewBox: e.viewport.getViewBox()
      };
    },
    // Destroy
    destroy: function() {
      return e.destroy(), e.pi;
    }
  }), this.publicInstance;
};
var Te = [], cs = function(e, t) {
  var n = fe.getSvg(e);
  if (n === null)
    return null;
  for (var o = Te.length - 1; o >= 0; o--)
    if (Te[o].svg === n)
      return Te[o].instance.getPublicInstance();
  return Te.push({
    svg: n,
    instance: new X(n, t)
  }), Te[Te.length - 1].instance.getPublicInstance();
}, us = cs;
const ds = /* @__PURE__ */ ts(us), fs = {
  getViewArea() {
    const e = this.getSizes(), t = this.getPan(), n = e.realZoom;
    t.x /= n, t.y /= n;
    const o = {
      width: e.width / n,
      height: e.height / n
    };
    return {
      box: {
        top: -t.y,
        bottom: o.height - t.y,
        left: -t.x,
        right: o.width - t.x
      },
      center: {
        x: o.width / 2 - t.x,
        y: o.height / 2 - t.y
      }
    };
  },
  getViewBox() {
    return this.getViewArea().box;
  },
  setViewBox(e) {
    const t = e.right - e.left, n = e.bottom - e.top, { width: o, height: i } = this.getSizes(), s = t / n, r = o / i, a = s < r ? n * r : t, l = s > r ? t / r : n, u = Math.min(
      o / a,
      i / l
    ), c = this.getRealZoom(), d = this.getZoom(), h = c / d;
    this.zoom(u / h);
    const v = {
      x: (e.left + t / 2) * u,
      y: (e.top + n / 2) * u
    };
    this.pan({
      x: -v.x + a / 2 * u,
      y: -v.y + l / 2 * u
    });
  },
  getRealZoom() {
    return this.getSizes().realZoom;
  },
  applyAbsoluteZoomLevel(e, t, n) {
    const o = Math.max(1e-4, t), i = Math.max(o, n), s = Math.max(Math.min(i, e), o), r = this.getRealZoom(), a = this.getZoom(), l = r / a;
    this.setMinZoom(o / l).setMaxZoom(i / l).zoom(s / l);
  },
  isPanEnabled() {
    return this._isPanEnabled;
  },
  enablePan() {
    return this._isPanEnabled = !0, this._internalEnablePan(), this;
  },
  disablePan() {
    return this._isPanEnabled = !1, this._internalDisablePan(), this;
  },
  isZoomEnabled() {
    return this._isZoomEnabled;
  },
  enableZoom() {
    return this._isZoomEnabled = !0, this._internalEnableZoom(), this;
  },
  disableZoom() {
    return this._isZoomEnabled = !1, this._internalDisableZoom(), this;
  },
  setPanEnabled(e) {
    return e ? this.enablePan() : this.disablePan(), this;
  },
  setZoomEnabled(e) {
    return e ? (this.enableZoom(), this.enableDblClickZoom()) : (this.disableZoom(), this.disableDblClickZoom()), this;
  }
};
function hs(e, t) {
  var o, i;
  const n = e;
  return n._isPanEnabled = (o = t.panEnabled) != null ? o : !0, n._isZoomEnabled = (i = t == null ? void 0 : t.zoomEnabled) != null ? i : !0, n._internalIsPanEnabled = n.isPanEnabled, n._internalEnablePan = n.enablePan, n._internalDisablePan = n.disablePan, n._internalIsZoomEnabled = n.isZoomEnabled, n._internalEnableZoom = n.enableZoom, n._internalDisableZoom = n.disableZoom, Object.assign(e, fs), n;
}
function vs(e, t) {
  var s, r, a, l, u, c;
  const n = (r = (s = t.customEventsHandler) == null ? void 0 : s.init) != null ? r : (d) => {
  }, o = (l = (a = t.customEventsHandler) == null ? void 0 : a.destroy) != null ? l : (d) => {
  }, i = (c = (u = t.customEventsHandler) == null ? void 0 : u.haltEventListeners) != null ? c : [];
  return t.mouseWheelZoomEnabled === void 0 && (t.mouseWheelZoomEnabled = t.zoomEnabled), t.customEventsHandler = {
    init: (d) => {
      hs(d.instance, t), n(d);
    },
    destroy: (d) => o(d),
    haltEventListeners: i
  }, ds(e, t);
}
function gs(e, t) {
  const n = j();
  let o = 0;
  const i = [], s = [], r = () => {
    o = 1, i.forEach((c) => c()), i.length = 0;
  }, a = () => {
    o = 2, s.forEach((c) => c()), s.length = 0;
  };
  return Ue(() => {
    var x, w, g, y, k, m;
    const c = q(e.value, "<svg>"), d = (w = (x = t.customEventsHandler) == null ? void 0 : x.init) != null ? w : (f) => {
    }, h = (y = (g = t.customEventsHandler) == null ? void 0 : g.destroy) != null ? y : (f) => {
    }, v = (m = (k = t.customEventsHandler) == null ? void 0 : k.haltEventListeners) != null ? m : [];
    t.customEventsHandler = {
      init: (f) => {
        n.value = f.instance, d(f), r();
      },
      destroy: (f) => {
        a(), h(f);
      },
      haltEventListeners: v
    };
    const E = () => {
      const f = c.getBoundingClientRect();
      f.width !== 0 && f.height !== 0 ? vs(c, t) : setTimeout(E, 200);
    };
    E();
  }), tt(() => {
    var c;
    (c = n.value) == null || c.destroy(), n.value = void 0;
  }), { svgPanZoom: n, onSvgPanZoomMounted: (c) => {
    o === 0 ? i.push(c) : o === 1 && c();
  }, onSvgPanZoomUnmounted: (c) => {
    o === 0 || o === 1 ? s.push(c) : c();
  } };
}
const no = Symbol("zoomLevel");
function ps(e, t) {
  const n = C(() => t.scalingObjects ? 1 : 1 / e.value);
  return Ze(no, {
    zoomLevel: e,
    scale: n
  }), { scale: n };
}
function be() {
  return q(De(no), "zoomLevel");
}
function ms(e) {
  return e instanceof Promise || e && typeof e.then == "function";
}
function bs() {
  let e = null;
  const t = j({
    enabled: !1,
    duration: 300,
    timingFunction: "linear"
  });
  function n(o, i = 300, s = "linear") {
    e && (clearTimeout(e), e = null), t.value = {
      enabled: !0,
      duration: i,
      timingFunction: s
    }, jt(() => Ee(this, null, function* () {
      const r = o();
      ms(r) && (yield r), e && clearTimeout(e), e = window == null ? void 0 : window.setTimeout(() => {
        t.value.enabled = !1, e = null;
      }, i);
    }));
  }
  return { transitionWhile: n, transitionOption: t };
}
function ys(e) {
  const t = j({}), n = j(!1);
  let o = 1;
  const i = /* @__PURE__ */ new Map();
  return me(() => {
    if (e.value instanceof Array) {
      const s = /* @__PURE__ */ new Set([]);
      if (t.value = Object.fromEntries(
        e.value.map((r) => {
          let a = r.id;
          return a || (n.value || (n.value = !0, console.warn(
            "[v-network-graph] Please specify the `id` field for the `Path` object. Currently, this works for compatibility, but in the future, the id field will be required."
          )), a = i.get(r), a || (a = "path-" + o++, i.set(r, a))), s.add(a), [a, r];
        })
      ), n.value)
        for (const [r, a] of Array.from(i.entries()))
          s.has(a) || i.delete(r);
    } else
      t.value = e.value;
  }), { objects: t, isInCompatibilityModeForPath: n };
}
function ws(e, t, n, o) {
  if (o) {
    const s = j(o(e[t])), r = (a) => {
      $e(a, s.value) || (s.value = a), $e(a, e[t]) || n(`update:${t}`, a);
    };
    return U(() => o(s.value), r), U(() => e[t], (a) => r(o(a))), s.value !== e[t] && n(`update:${t}`, s.value), s;
  }
  const i = j(e[t]);
  return U(
    () => e[t],
    (s) => {
      $e(s, i.value) || (i.value = s);
    }
  ), U(i, (s) => {
    $e(s, e[t]) || n(`update:${t}`, s);
  }), i;
}
function It(e, t, n, o) {
  const i = Oe(/* @__PURE__ */ new Set());
  return U(
    () => e[t],
    () => {
      const r = e[t].filter((a) => a in n.value);
      $e(r, Array.from(i)) || (i.clear(), r.forEach(i.add, i));
    },
    { deep: !0, immediate: !0 }
  ), U(i, () => {
    const s = Array.from(i);
    $e(e[t], s) || o(`update:${t}`, s);
  }), Ie(i);
}
const oo = Symbol("selection");
function Es(e, t, n) {
  Ze(oo, {
    selectedNodes: e,
    selectedEdges: t,
    selectedPaths: n
  });
}
function xs() {
  return q(De(oo), "Selections");
}
const io = Symbol("layouts");
function ks(e) {
  Ze(io, e);
}
function Jt() {
  return q(De(io), "Layouts");
}
function Ps(e, t) {
  for (let n = 0; n < e.length - 1; n++)
    t(e[n], e[n + 1]);
}
function Ye(e, t) {
  const n = e.indexOf(t);
  n >= 0 && e.splice(n, 1);
}
function Ss(e, t, n) {
  const o = e.indexOf(t);
  o < 0 || e.splice(o + 1, 0, n);
}
function Ms(e, t) {
  const n = [
    "edges",
    "edge-labels",
    "focusring",
    "nodes",
    "node-labels",
    "paths"
  ];
  return C(() => {
    const o = Fo(e.view.builtInLayerOrder).filter((s) => {
      const r = n.includes(s);
      return r || console.warn(`Layer ${s} is not a built-in layer.`), r;
    }).reverse(), i = [...n];
    return Ps(o, (s, r) => {
      Ye(i, r), Ss(i, s, r);
    }), "edge-label" in t || "edges-label" in t || Ye(i, "edge-labels"), e.node.focusring.visible || Ye(i, "focusring"), e.node.label.visible === !1 && Ye(i, "node-labels"), e.path.visible || Ye(i, "paths"), i;
  });
}
const Pn = () => new Promise((e) => jt(e));
function Cs(e, t) {
  const n = Math.max(e.width, e.height, t.width, t.height) / 1e4;
  return Math.abs(e.x - t.x) < n && Math.abs(e.y - t.y) < n && Math.abs(e.width - t.width) < n && Math.abs(e.height - t.height) < n;
}
function Os(e, t) {
  return {
    top: e.top + t.top,
    left: e.left + t.left,
    right: e.right + t.right,
    bottom: e.bottom + t.bottom
  };
}
function zs(e, t) {
  return {
    top: e.top * t,
    left: e.left * t,
    right: e.right * t,
    bottom: e.bottom * t
  };
}
function Ts(e, t) {
  return {
    top: e.top / t,
    left: e.left / t,
    right: e.right / t,
    bottom: e.bottom / t
  };
}
function so(e) {
  return {
    top: e.y,
    left: e.x,
    right: e.x + e.width,
    bottom: e.y + e.height
  };
}
function ro(e) {
  return {
    x: e.left,
    y: e.top,
    width: e.right - e.left,
    height: e.bottom - e.top
  };
}
function Is(e, t) {
  return {
    top: Math.min(e.top, t.top),
    left: Math.min(e.left, t.left),
    right: Math.max(e.right, t.right),
    bottom: Math.max(e.bottom, t.bottom)
  };
}
const $s = new RegExp("^\\d+$");
function Ls(e, t) {
  let n = { top: 0, left: 0, right: 0, bottom: 0 };
  if (typeof e == "string") {
    const o = We(e, t.width), i = We(e, t.height);
    o === void 0 || i === void 0 ? console.warn("Invalid `fitContentMargin` value.", e) : n = { top: i, left: o, right: o, bottom: i };
  } else if (typeof e == "number") {
    const o = e;
    n = { top: o, left: o, right: o, bottom: o };
  } else {
    if (e.top) {
      const o = We(e.top, t.height);
      o === void 0 ? console.warn("Invalid `fitContentMargin` value.", e.top) : n.top = o;
    }
    if (e.left) {
      const o = We(e.left, t.width);
      o === void 0 ? console.warn("Invalid `fitContentMargin` value.", e.left) : n.left = o;
    }
    if (e.right) {
      const o = We(e.right, t.width);
      o === void 0 ? console.warn("Invalid `fitContentMargin` value.", e.right) : n.right = o;
    }
    if (e.bottom) {
      const o = We(e.bottom, t.height);
      o === void 0 ? console.warn("Invalid `fitContentMargin` value.", e.bottom) : n.bottom = o;
    }
  }
  return n;
}
function As(e, t, n, o, i, s) {
  const r = e.getBBox();
  if (s)
    return Ds(r, t, n, i);
  {
    const a = Zs(e);
    return Ns(
      r,
      a,
      t,
      n,
      o,
      i
    );
  }
}
function We(e, t) {
  if (typeof e == "string") {
    if (e.endsWith("%")) {
      const n = parseInt(e.toString());
      if (Number.isFinite(n))
        return t * (n / 100);
    } else if (e.endsWith("px") || $s.test(e)) {
      const n = parseInt(e.toString());
      if (Number.isFinite(n))
        return n;
    }
  } else if (typeof e == "number")
    return e;
}
function Zs(e) {
  return Array.from(e.querySelectorAll(".v-ng-graph-objects")).map(
    (n) => n.getBBox()
  ).reduce(
    (n, o, i) => {
      if (i === 0) return o;
      const s = Math.min(n.x, o.x), r = Math.min(n.y, o.y);
      return {
        x: s,
        y: r,
        width: Math.max(n.x + n.width - s, o.x + o.width - s),
        height: Math.max(n.y + n.height - r, o.y + o.height - r)
      };
    },
    { x: 0, y: 0, width: 0, height: 0 }
  );
}
function Ds(e, t, n, o) {
  if (Object.keys(n).length <= 1)
    return;
  const i = ao(e, t, o);
  if (i > 0) {
    const s = so(e);
    return {
      zoom: i,
      pos: lo(s, i, t, o)
    };
  } else
    return;
}
function Ns(e, t, n, o, i, s) {
  if (Object.keys(o).length <= 1)
    return;
  const r = vi(o), a = {
    top: (r.top - t.y) * i,
    left: (r.left - t.x) * i,
    right: (t.x + t.width - r.right) * i,
    bottom: (t.y + t.height - r.bottom) * i
  };
  let l = ao(e, n, s);
  if (l === 0)
    return;
  const u = ht(n, Os(s, a));
  if (u.width <= 0 || u.height <= 0)
    return;
  const c = so(e), d = ht(n, s), h = Cs(e, t);
  let v = 0, E = 0, x = { top: 0, left: 0, right: 0, bottom: 0 };
  do {
    E = l;
    const w = Ts(a, l), g = {
      top: r.top - w.top,
      left: r.left - w.left,
      right: r.right + w.right,
      bottom: r.bottom + w.bottom
    };
    x = h ? g : Is(c, g);
    const y = ro(x), m = [d.width / y.width, d.height / y.height].filter((f) => f > 0);
    if (m.length === 0)
      return;
    l = Math.min(...m), v++;
  } while (Math.abs(E - l) > 1e-6 && v < 10);
  return {
    zoom: l,
    pos: lo(x, l, n, s)
  };
}
function ao(e, t, n) {
  if (e.width === 0 || e.height === 0) return 0;
  const o = ht(t, n);
  if (o.width <= 0 || o.height <= 0)
    return 0;
  const i = [o.width / e.width, o.height / e.height];
  return Math.min(...i);
}
function lo(e, t, n, o) {
  const i = ht(n, o), s = ro(zs(e, t)), r = (i.width - s.width) / 2, a = (i.height - s.height) / 2, l = s.x - o.left, u = s.y - o.top;
  return {
    x: -l + r,
    y: -u + a
  };
}
function ht(e, t) {
  const n = t.left + t.right, o = t.top + t.bottom;
  return {
    width: e.width - n,
    height: e.height - o
  };
}
const js = ["x", "y", "width", "height", "fill", "stroke", "stroke-width", "stroke-dasharray"], Bs = /* @__PURE__ */ _({
  __name: "VSelectionBox",
  props: {
    box: null,
    config: null
  },
  setup(e) {
    return (t, n) => (M(), L("rect", {
      class: "v-ng-selection-box",
      x: Math.round(e.box.pos.x),
      y: Math.round(e.box.pos.y),
      width: Math.ceil(e.box.size.width),
      height: Math.ceil(e.box.size.height),
      fill: e.config.color,
      stroke: e.config.strokeColor,
      "stroke-width": e.config.strokeWidth,
      "stroke-dasharray": e.config.strokeDasharray
    }, null, 8, js));
  }
}), Rs = ["points", "fill"], Vs = /* @__PURE__ */ _({
  __name: "VMarkerHeadArrow",
  props: {
    width: null,
    height: null,
    refX: null,
    color: null,
    isSource: { type: Boolean },
    units: null
  },
  setup(e) {
    const t = e, n = C(() => {
      const o = t.width, i = t.height;
      return t.isSource ? `${o} ${i}, 0 ${i / 2}, ${o} 0` : `0 0, ${o} ${i / 2}, 0 ${i}`;
    });
    return (o, i) => (M(), L("polygon", {
      points: b(n),
      fill: e.color
    }, null, 8, Rs));
  }
}), Ws = ["points", "stroke-width", "stroke"], Hs = /* @__PURE__ */ _({
  __name: "VMarkerHeadAngle",
  props: {
    width: null,
    height: null,
    refX: null,
    color: null,
    isSource: { type: Boolean },
    units: null
  },
  setup(e) {
    const t = e, n = C(() => t.units === "strokeWidth" ? 1 : Math.min(t.width, t.height) / 5), o = C(() => {
      const i = n.value / 2, s = t.width, r = t.height;
      return t.isSource ? `${s - i} ${r - i}, ${i} ${r / 2}, ${s - i} ${i}` : `${i} ${i}, ${s - i} ${r / 2}, ${i} ${r - i}`;
    });
    return (i, s) => (M(), L("polyline", {
      points: b(o),
      fill: "none",
      "stroke-width": b(n),
      stroke: e.color,
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }, null, 8, Ws));
  }
}), _s = ["fill", "cx", "cy", "rx", "ry"], Fs = /* @__PURE__ */ _({
  __name: "VMarkerHeadCircle",
  props: {
    width: null,
    height: null,
    refX: null,
    color: null,
    isSource: { type: Boolean },
    units: null
  },
  setup(e) {
    return (t, n) => (M(), L("ellipse", {
      fill: e.color,
      cx: e.width / 2,
      cy: e.height / 2,
      rx: e.width / 2,
      ry: e.height / 2
    }, null, 8, _s));
  }
}), Us = ["id", "markerWidth", "markerHeight", "refX", "refY", "markerUnits"], Xs = /* @__PURE__ */ _({
  __name: "VMarkerHead",
  props: {
    id: null,
    marker: null,
    scale: null
  },
  setup(e) {
    const t = e, n = {
      arrow: Vs,
      angle: Hs,
      circle: Fs
    }, o = C(
      () => t.marker.width * (t.marker.units === "strokeWidth" ? 1 : t.scale)
    ), i = C(
      () => t.marker.height * (t.marker.units === "strokeWidth" ? 1 : t.scale)
    ), s = C(() => {
      const a = t.marker.margin * (t.marker.units === "strokeWidth" ? 1 : t.scale);
      return t.marker.isSource ? o.value + a : -a;
    }), r = C(() => {
      const a = t.marker.offset * (t.marker.units === "strokeWidth" ? 1 : t.scale);
      return t.marker.isSource ? a : -a;
    });
    return (a, l) => e.marker.type !== "none" && e.marker.type !== "custom" ? (M(), L("marker", {
      key: 0,
      id: e.id,
      markerWidth: b(o),
      markerHeight: b(i),
      refX: b(s),
      refY: b(i) / 2 + b(r),
      orient: "auto",
      markerUnits: e.marker.units,
      class: "v-ng-marker"
    }, [
      (M(), H(On(n[e.marker.type]), {
        width: b(o),
        height: b(i),
        refX: b(s),
        color: e.marker.color,
        "is-source": e.marker.isSource,
        units: e.marker.units
      }, null, 8, ["width", "height", "refX", "color", "is-source", "units"]))
    ], 8, Us)) : ce("", !0);
  }
}), qs = {
  class: "v-ng-background-grid",
  "shape-rendering": "crispEdges"
}, Gs = ["d"], Ks = ["d"], Ys = ["d"], Qs = ["d"], Js = /* @__PURE__ */ _({
  __name: "VBackgroundGrid",
  setup(e) {
    const { container: t, svgPanZoom: n } = Vt(), { zoomLevel: o } = be(), i = es(), s = Yo(), r = j({ x: 0, y: 0 }), a = j({ width: 500, height: 500 });
    Ue(() => {
      var E;
      const h = (E = n.value) == null ? void 0 : E.getPan();
      h && (r.value = {
        x: -h.x,
        y: -h.y
      });
      const v = t.value.getBoundingClientRect();
      a.value = {
        width: v.width,
        height: v.height
      };
    }), i.on("view:resize", (h) => {
      a.value = { width: h.width, height: h.height };
    }), i.on("view:pan", (h) => {
      r.value = { x: -h.x, y: -h.y };
    }), i.on("view:zoom", () => {
      var v;
      const h = (v = n.value) == null ? void 0 : v.getPan();
      h && (r.value = { x: -h.x, y: -h.y });
    });
    const l = j([]), u = j([]), c = j([]), d = j([]);
    return me(() => {
      const h = [], v = [], E = [], x = [], w = 1 / o.value, g = s.grid.interval, y = r.value.x * w, k = r.value.y * w, m = Math.floor(a.value.width / g + 1) * g, f = Math.floor(a.value.height / g + 1) * g, p = (r.value.x + m) * w, S = (r.value.y + f) * w, O = s.grid.thickIncrements, I = s.grid.line.dasharray, z = s.grid.thick.dasharray;
      let T = {
        stroke: s.grid.thick.color,
        "stroke-width": s.grid.thick.width,
        "stroke-dasharray": z,
        "stroke-dashoffset": z ? y / w : void 0
      }, A = {
        stroke: s.grid.line.color,
        "stroke-width": s.grid.line.width,
        "stroke-dasharray": I,
        "stroke-dashoffset": I ? y / w : void 0
      };
      const R = (r.value.x + m) * w;
      for (let B = k; B <= S; B += g) {
        const F = Math.floor(B / g);
        O && F % O === 0 ? h.push([F, F * g, y, R, T]) : E.push([F, F * g, y, R, A]);
      }
      T = se({}, T), T["stroke-dashoffset"] = z ? k / w : void 0, A = se({}, A), A["stroke-dashoffset"] = I ? k / w : void 0;
      const Y = (r.value.y + f) * w;
      for (let B = y; B <= p; B += g) {
        const F = Math.floor(B / g);
        O && F % O === 0 ? v.push([F, F * g, k, Y, T]) : x.push([F, F * g, k, Y, A]);
      }
      u.value = h, l.value = v, d.value = E, c.value = x;
    }), (h, v) => (M(), L("g", qs, [
      (M(!0), L(G, null, J(d.value, ([E, x, w, g, y]) => (M(), L("path", Pe({
        key: `nv${E}`,
        d: `M ${w} ${x} L ${g} ${x}`
      }, y, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, Gs))), 128)),
      (M(!0), L(G, null, J(c.value, ([E, x, w, g, y]) => (M(), L("path", Pe({
        key: `nh${E}`,
        d: `M ${x} ${w} L ${x} ${g}`
      }, y, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, Ks))), 128)),
      (M(!0), L(G, null, J(u.value, ([E, x, w, g, y]) => (M(), L("path", Pe({
        key: `tv${E}`,
        d: `M ${w} ${x} L ${g} ${x}`
      }, y, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, Ys))), 128)),
      (M(!0), L(G, null, J(l.value, ([E, x, w, g, y]) => (M(), L("path", Pe({
        key: `th${E}`,
        d: `M ${x} ${w} L ${x} ${g}`
      }, y, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, Qs))), 128))
    ]));
  }
}), er = /* @__PURE__ */ _({
  __name: "VBackgroundViewport",
  setup(e) {
    const { viewport: t } = Vt(), n = j(), o = (s, r, a) => {
      s.forEach((l) => {
        var u;
        return r.setAttribute(l, (u = a.getAttribute(l)) != null ? u : "");
      });
    }, i = new MutationObserver((s) => {
      if (!n.value) return;
      const r = s.map((a) => {
        var l;
        return (l = a.attributeName) != null ? l : "";
      }).filter(Boolean);
      o(r, n.value, t.value);
    });
    return Ue(() => {
      const s = ["transform", "style"];
      i.observe(t.value, {
        attributes: !0,
        attributeFilter: s
      }), n.value && o(s, n.value, t.value);
    }), tt(() => {
      i.disconnect();
    }), (s, r) => (M(), L("g", {
      ref_key: "background",
      ref: n,
      class: "v-ng-background-viewport"
    }, [
      K(s.$slots, "default")
    ], 512));
  }
}), tr = ["d", "stroke-width"], nr = /* @__PURE__ */ _({
  __name: "VEdgeBackground",
  props: {
    id: null,
    state: null,
    sourcePos: { default: void 0 },
    targetPos: { default: void 0 }
  },
  setup(e) {
    const t = e, { scale: n } = be(), o = bt(), {
      handleEdgePointerDownEvent: i,
      handleEdgePointerOverEvent: s,
      handleEdgePointerOutEvent: r,
      handleEdgeClickEvent: a,
      handleEdgeDoubleClickEvent: l,
      handleEdgeContextMenu: u
    } = it(), c = C(() => {
      const h = t.state.position;
      if (t.state.loop) {
        const { radius: v, isLargeArc: E, isClockwise: x } = t.state.loop, [w, g] = v, y = E ? 1 : 0, k = x ? 1 : 0;
        return `M ${h.p1.x} ${h.p1.y} A ${w} ${g} 0 ${y} ${k} ${h.p2.x} ${h.p2.y}`;
      } else {
        if (o.type === "straight" || !t.state.curve)
          return `M ${h.p1.x} ${h.p1.y} L ${h.p2.x} ${h.p2.y}`;
        {
          const v = [...t.state.curve.control, { x: h.p2.x, y: h.p2.y }], E = [];
          return E.push(`M ${h.p1.x} ${h.p1.y}`), Rt(v, 2).forEach(([x, w]) => E.push(`Q ${x.x} ${x.y} ${w.x} ${w.y}`)), E.join(" ");
        }
      }
    }), d = C(() => (t.state.line.stroke.width + 10) * n.value);
    return (h, v) => (M(), L("path", {
      class: ve({ "v-ng-line-background": !0, selectable: e.state.selectable }),
      d: b(c),
      stroke: "transparent",
      "stroke-width": b(d),
      fill: "none",
      onPointerdown: v[0] || (v[0] = xe((E) => b(i)(e.id, E), ["stop"])),
      onPointerenterPassive: v[1] || (v[1] = (E) => b(s)(e.id, E)),
      onPointerleavePassive: v[2] || (v[2] = (E) => b(r)(e.id, E)),
      onClick: v[3] || (v[3] = xe((E) => b(a)(e.id, E), ["stop"])),
      onDblclick: v[4] || (v[4] = xe((E) => b(l)(e.id, E), ["stop"])),
      onContextmenu: v[5] || (v[5] = (E) => b(u)(e.id, E))
    }, null, 42, tr));
  }
}), or = /* @__PURE__ */ _({
  __name: "VEdgeBackgrounds",
  setup(e) {
    const { edgeStates: t, edgeGroupStates: n, layouts: o } = Se();
    return (i, s) => (M(!0), L(G, null, J(b(n).edgeGroups, ({ summarize: r, edges: a }) => (M(), L(G, null, [
      r ? ce("", !0) : (M(!0), L(G, { key: 0 }, J(a, (l, u) => (M(), H(nr, {
        key: u,
        id: u,
        state: b(t)[u],
        "source-pos": b(o).nodes[l.source],
        "target-pos": b(o).nodes[l.target]
      }, null, 8, ["id", "state", "source-pos", "target-pos"]))), 128))
    ], 64))), 256));
  }
}), ir = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap"], co = /* @__PURE__ */ _({
  __name: "VLine",
  props: {
    p1: null,
    p2: null,
    config: null
  },
  setup(e) {
    const t = e, { scale: n } = be(), o = C(() => t.config.width * n.value), i = C(() => ot(t.config.dasharray, n.value)), s = C(() => {
      const r = t.config.animate ? gt(t.config.dasharray) * t.config.animationSpeed * n.value : !1;
      return r ? { "--animation-speed": r } : void 0;
    });
    return (r, a) => (M(), L("path", {
      class: ve({ "v-ng-line": !0, animate: e.config.animate }),
      d: `M ${e.p1.x} ${e.p1.y} L ${e.p2.x} ${e.p2.y}`,
      stroke: e.config.color,
      "stroke-width": b(o),
      "stroke-dasharray": b(i),
      "stroke-linecap": e.config.linecap,
      style: nt(b(s))
    }, null, 14, ir));
  }
}), sr = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap"], rr = /* @__PURE__ */ _({
  __name: "VArc",
  props: {
    p1: null,
    p2: null,
    radius: null,
    isLargeArc: { type: Boolean },
    isClockwise: { type: Boolean },
    config: null
  },
  setup(e) {
    const t = e, { scale: n } = be(), o = C(() => t.config.width * n.value), i = C(() => ot(t.config.dasharray, n.value)), s = C(() => {
      const a = t.config.animate ? gt(t.config.dasharray) * t.config.animationSpeed * n.value : !1;
      return a ? { "--animation-speed": a } : void 0;
    }), r = C(() => {
      const { p1: a, p2: l, radius: u, isLargeArc: c, isClockwise: d } = t, [h, v] = u, E = c ? 1 : 0, x = d ? 1 : 0;
      return `M ${a.x} ${a.y} A ${h} ${v} 0 ${E} ${x} ${l.x} ${l.y}`;
    });
    return (a, l) => (M(), L("path", {
      class: ve({ "v-ng-line": !0, animate: e.config.animate }),
      d: b(r),
      stroke: e.config.color,
      "stroke-width": b(o),
      "stroke-dasharray": b(i),
      "stroke-linecap": e.config.linecap,
      style: nt(b(s)),
      fill: "none"
    }, null, 14, sr));
  }
}), ar = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "marker-start", "marker-end"], lr = /* @__PURE__ */ _({
  __name: "VEdgeCurved",
  props: {
    state: null,
    config: null,
    markerStart: { default: void 0 },
    markerEnd: { default: void 0 }
  },
  setup(e) {
    const t = e, { scale: n } = be(), o = C(() => {
      var c, d;
      const a = t.state.position, l = [...(d = (c = t.state.curve) == null ? void 0 : c.control) != null ? d : [], { x: a.p2.x, y: a.p2.y }], u = [];
      return u.push(`M ${a.p1.x} ${a.p1.y}`), Rt(l, 2).forEach(([h, v]) => u.push(`Q ${h.x} ${h.y} ${v.x} ${v.y}`)), u.join(" ");
    }), i = C(() => t.config.width * n.value), s = C(() => ot(t.config.dasharray, n.value)), r = C(() => {
      const a = t.config.animate ? gt(t.config.dasharray) * t.config.animationSpeed * n.value : !1;
      return a ? { "--animation-speed": a } : void 0;
    });
    return (a, l) => (M(), L("path", {
      class: ve({ "v-ng-line": !0, animate: e.config.animate }),
      d: b(o),
      fill: "none",
      stroke: e.config.color,
      "stroke-width": b(i),
      "stroke-dasharray": b(s),
      "stroke-linecap": e.config.linecap,
      style: nt(b(r)),
      "marker-start": e.markerStart,
      "marker-end": e.markerEnd
    }, null, 14, ar));
  }
}), cr = /* @__PURE__ */ _({
  __name: "VEdge",
  props: {
    id: null,
    state: null,
    sourcePos: { default: void 0 },
    targetPos: { default: void 0 }
  },
  setup(e) {
    const t = bt();
    return (n, o) => e.state.loop ? (M(), H(rr, Pe({ key: 0 }, e.state.position, {
      radius: e.state.loop.radius,
      "is-large-arc": e.state.loop.isLargeArc,
      "is-clockwise": e.state.loop.isClockwise,
      class: [{ selectable: e.state.selectable, hover: e.state.hovered, selected: e.state.selected }, "v-ng-edge"],
      config: e.state.line.stroke,
      "marker-start": e.state.sourceMarkerId ? `url('#${e.state.sourceMarkerId}')` : void 0,
      "marker-end": e.state.targetMarkerId ? `url('#${e.state.targetMarkerId}')` : void 0
    }), null, 16, ["radius", "is-large-arc", "is-clockwise", "class", "config", "marker-start", "marker-end"])) : b(t).type == "straight" || !e.state.curve ? (M(), H(co, Pe({
      key: 1,
      "data-edge-id": e.id
    }, e.state.position, {
      class: [{ selectable: e.state.selectable, hover: e.state.hovered, selected: e.state.selected }, "v-ng-edge"],
      config: e.state.line.stroke,
      "marker-start": e.state.sourceMarkerId ? `url('#${e.state.sourceMarkerId}')` : void 0,
      "marker-end": e.state.targetMarkerId ? `url('#${e.state.targetMarkerId}')` : void 0
    }), null, 16, ["data-edge-id", "class", "config", "marker-start", "marker-end"])) : (M(), H(lr, {
      key: 2,
      "data-edge-id": e.id,
      class: ve([{ selectable: e.state.selectable, hover: e.state.hovered, selected: e.state.selected }, "v-ng-edge"]),
      state: e.state,
      config: e.state.line.stroke,
      "marker-start": e.state.sourceMarkerId ? `url('#${e.state.sourceMarkerId}')` : void 0,
      "marker-end": e.state.targetMarkerId ? `url('#${e.state.targetMarkerId}')` : void 0
    }, null, 8, ["data-edge-id", "class", "state", "config", "marker-start", "marker-end"]));
  }
}), ur = ["cx", "cy", "r", "fill", "stroke", "stroke-width", "stroke-dasharray"], dr = ["x", "y", "width", "height", "rx", "ry", "fill", "stroke", "stroke-width", "stroke-dasharray"], Et = /* @__PURE__ */ _({
  __name: "VShape",
  props: {
    baseX: { default: 0 },
    baseY: { default: 0 },
    config: null
  },
  setup(e) {
    const t = e, { scale: n } = be(), o = j(t.baseX), i = j(t.baseY), s = j(0), r = j("#000000"), a = j(void 0), l = j(0), u = j(0), c = j(0), d = j(0);
    return me(() => {
      var v;
      const h = n.value;
      s.value = t.config.strokeWidth * h, r.value = (v = t.config.strokeColor) != null ? v : "none", a.value = ot(t.config.strokeDasharray, h), t.config.type === "circle" ? (o.value = t.baseX, i.value = t.baseY, l.value = t.config.radius * h) : (u.value = t.config.width * h, c.value = t.config.height * h, d.value = t.config.borderRadius * h, o.value = t.baseX - u.value / 2, i.value = t.baseY - c.value / 2);
    }), (h, v) => e.config.type === "circle" ? (M(), L("circle", {
      key: 0,
      class: "v-ng-shape-circle",
      cx: o.value,
      cy: i.value,
      r: l.value,
      fill: e.config.color,
      stroke: r.value,
      "stroke-width": s.value,
      "stroke-dasharray": a.value
    }, null, 8, ur)) : (M(), L("rect", {
      key: 1,
      class: "v-ng-shape-rect",
      x: o.value,
      y: i.value,
      width: u.value,
      height: c.value,
      rx: d.value,
      ry: d.value,
      fill: e.config.color,
      stroke: r.value,
      "stroke-width": s.value,
      "stroke-dasharray": a.value
    }, null, 8, dr));
  }
}), fr = ["rx", "ry", "fill", "transform"], hr = ["x", "y", "dominant-baseline", "font-family", "font-size", "fill"], vr = ["x", "dy", "dominant-baseline"], xt = /* @__PURE__ */ _({
  __name: "VLabelText",
  props: {
    text: null,
    x: { default: 0 },
    y: { default: 0 },
    dominantBaseline: { default: "central" },
    config: null
  },
  setup(e) {
    const t = e, n = Bo(), { scale: o } = be(), i = C(() => {
      var w, g;
      return (g = (w = t.text) == null ? void 0 : w.toString().split(/\r?\n/)) != null ? g : "";
    }), s = C(() => {
      var w;
      return (w = n["font-size"]) != null ? w : t.config.fontSize * o.value;
    }), r = C(() => s.value * t.config.lineHeight), a = C(() => {
      const w = t.dominantBaseline;
      return w === "hanging" ? 0 : w === "central" ? -(r.value * (i.value.length - 1)) / 2 : -r.value * (i.value.length - 1);
    }), l = j(), u = j(""), c = Oe({ x: 0, y: 0, width: 0, height: 0 }), d = C(() => {
      var m, f;
      const w = t.config.background;
      if (!w) return c;
      let g, y;
      w.padding instanceof Object ? (g = w.padding.vertical, y = w.padding.horizontal) : (g = (m = w.padding) != null ? m : 0, y = (f = w.padding) != null ? f : 0);
      const k = r.value - s.value;
      return {
        x: c.x - y * o.value,
        y: c.y - g * o.value - k / 2,
        width: c.width + y * 2 * o.value,
        height: c.height + g * 2 * o.value + k
      };
    });
    let h;
    const v = () => {
      t.config.background && t.config.background.visible ? !h && l.value && (h = x(l.value, c, u)) : (h == null || h.disconnect(), h = void 0);
    };
    Ue(() => v()), U(
      () => t.config.background && t.config.background.visible,
      (w, g) => {
        w != g && v();
      }
    ), tt(() => {
      h == null || h.disconnect(), h = void 0;
    });
    function E(w, g, y) {
      var m;
      const k = w.getBBox();
      g.x = k.x, g.y = k.y, g.width = k.width, g.height = k.height, y.value = (m = w.getAttribute("transform")) != null ? m : void 0;
    }
    function x(w, g, y) {
      const k = new MutationObserver(() => {
        E(w, g, y);
      });
      return k.observe(w, {
        attributes: !0,
        attributeFilter: ["x", "y", "transform", "font-size"]
      }), E(w, g, y), k;
    }
    return (w, g) => {
      var y, k, m, f, p, S;
      return M(), L(G, null, [
        e.config.background && e.config.background.visible ? (M(), L("rect", Pe({
          key: 0,
          class: "v-ng-text-background"
        }, b(d), {
          rx: ((k = (y = e.config.background) == null ? void 0 : y.borderRadius) != null ? k : 0) * b(o),
          ry: ((f = (m = e.config.background) == null ? void 0 : m.borderRadius) != null ? f : 0) * b(o),
          fill: (S = (p = e.config.background) == null ? void 0 : p.color) != null ? S : "#ffffff",
          transform: u.value
        }), null, 16, fr)) : ce("", !0),
        zn("text", Pe({
          ref_key: "element",
          ref: l,
          class: "v-ng-text"
        }, w.$attrs, {
          x: e.x,
          y: e.y,
          "dominant-baseline": e.dominantBaseline,
          "font-family": w.$attrs["font-family"] ? `${w.$attrs["font-family"]}` : e.config.fontFamily,
          "font-size": b(s),
          fill: w.$attrs.fill ? `${w.$attrs.fill}` : e.config.color
        }), [
          b(i).length <= 1 ? (M(), L(G, { key: 0 }, [
            Ro(cn(e.text), 1)
          ], 64)) : (M(!0), L(G, { key: 1 }, J(b(i), (O, I) => (M(), L("tspan", {
            key: I,
            x: e.x,
            dy: I == 0 ? b(a) : b(r),
            "dominant-baseline": e.dominantBaseline
          }, cn(O), 9, vr))), 128))
        ], 16, hr)
      ], 64);
    };
  }
}), gr = /* @__PURE__ */ _({
  __name: "VEdgeSummarized",
  props: {
    edges: null,
    layouts: null
  },
  setup(e) {
    const t = e, n = bt(), {
      handleEdgesPointerDownEvent: o,
      handleEdgesPointerOverEvent: i,
      handleEdgesPointerOutEvent: s,
      handleEdgesClickEvent: r,
      handleEdgesDoubleClickEvent: a,
      handleEdgesContextMenu: l
    } = it(), { edgeStates: u } = Se(), c = j({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } }), d = j({ x: 0, y: 0 });
    me(() => {
      const k = Object.keys(t.edges).find((m) => m in u);
      k && (c.value = u[k].position, d.value = {
        x: (c.value.p1.x + c.value.p2.x) / 2,
        y: (c.value.p1.y + c.value.p2.y) / 2
      });
    });
    const h = C(() => Object.keys(t.edges)), v = C(() => $.values(n.summarized.label, t.edges)), E = C(() => $.values(n.summarized.shape, t.edges)), x = C(() => $.values(n.summarized.stroke, t.edges)), w = C(() => h.value.some((k) => u[k].hovered)), g = C(() => h.value.some((k) => u[k].selectable)), y = C(() => h.value.some((k) => u[k].selected));
    return (k, m) => (M(), L("g", {
      class: ve({ "v-ng-line-summarized": !0, hovered: b(w), selectable: b(g), selected: b(y) }),
      onPointerdown: m[0] || (m[0] = xe((f) => b(o)(b(h), f), ["stop"])),
      onPointerenterPassive: m[1] || (m[1] = (f) => b(i)(b(h), f)),
      onPointerleavePassive: m[2] || (m[2] = (f) => b(s)(b(h), f)),
      onClick: m[3] || (m[3] = xe((f) => b(r)(b(h), f), ["stop"])),
      onDblclick: m[4] || (m[4] = xe((f) => b(a)(b(h), f), ["stop"])),
      onContextmenu: m[5] || (m[5] = (f) => b(l)(b(h), f))
    }, [
      Re(co, Pe(c.value, {
        config: b(x),
        "data-edge-id": b(h)[0]
      }), null, 16, ["config", "data-edge-id"]),
      Re(Et, {
        "base-x": d.value.x,
        "base-y": d.value.y,
        config: b(E)
      }, null, 8, ["base-x", "base-y", "config"]),
      Re(xt, {
        text: Object.keys(e.edges).length.toString(),
        x: d.value.x,
        y: d.value.y,
        config: b(v),
        "text-anchor": "middle",
        "dominant-baseline": "central"
      }, null, 8, ["text", "x", "y", "config"])
    ], 34));
  }
}), pr = { class: "v-ng-edge-overlay" }, Sn = /* @__PURE__ */ _({
  __name: "VEdgeOverlay",
  props: {
    edgeId: { default: void 0 },
    edge: { default: void 0 },
    edges: { default: () => ({}) },
    state: null,
    isSummarized: { type: Boolean }
  },
  setup(e) {
    const t = e, { svg: n } = Vt(), { scale: o } = be(), i = bt();
    function s() {
      return t.isSummarized ? $.values(i.summarized.stroke, t.edges) : t.state.line.stroke;
    }
    function r(c) {
      return { source: c.p1, target: c.p2 };
    }
    function a(c) {
      if (c.curve)
        return c.curve.center;
      {
        const d = c.origin.p1, h = c.origin.p2;
        return {
          x: (d.x + h.x) / 2,
          y: (d.y + h.y) / 2
        };
      }
    }
    function l() {
      var h;
      if (!n.value) return 0;
      const c = (h = t.edgeId) != null ? h : Object.keys(t.edges)[0], d = n.value.querySelector(`path[data-edge-id="${c}"]`);
      return d ? d.getTotalLength() : 0;
    }
    function u(c) {
      var E;
      if (!n.value || !isFinite(c)) return t.state.position.p1;
      t.state;
      const d = (E = t.edgeId) != null ? E : Object.keys(t.edges)[0], h = n.value.querySelector(`path[data-edge-id="${d}"]`);
      if (!h) return t.state.position.p1;
      const v = h.getPointAtLength(c);
      return { x: v.x, y: v.y };
    }
    return (c, d) => (M(), L("g", pr, [
      e.isSummarized ? K(c.$slots, "default", {
        key: 0,
        edges: e.edges,
        isSummarized: e.isSummarized,
        stroke: s(),
        position: r(e.state.origin),
        center: a(e.state),
        hovered: e.state.hovered,
        selected: e.state.selected,
        scale: b(o),
        length: l(),
        pointAtLength: u
      }) : K(c.$slots, "default", {
        key: 1,
        edgeId: e.edgeId,
        edge: e.edge,
        edges: { [e.edgeId]: e.edge },
        isSummarized: e.isSummarized,
        stroke: s(),
        position: r(e.state.origin),
        center: a(e.state),
        hovered: e.state.hovered,
        selected: e.state.selected,
        scale: b(o),
        length: l(),
        pointAtLength: u
      })
    ]));
  }
}), mr = /* @__PURE__ */ _({
  __name: "VEdgeGroups",
  props: {
    hasEdgeOverlaySlot: { type: Boolean }
  },
  setup(e) {
    const { edgeStates: t, edgeZOrderedList: n, layouts: o } = Se();
    return (i, s) => (M(!0), L(G, null, J(b(n), (r) => (M(), L(G, null, [
      b(Oi)(r) ? (M(), L(G, { key: 0 }, [
        (M(), H(gr, {
          key: r.key,
          edges: r.group.edges,
          layouts: b(o).nodes
        }, null, 8, ["edges", "layouts"])),
        e.hasEdgeOverlaySlot ? (M(), H(Sn, {
          key: r.key,
          edges: r.group.edges,
          state: b(t)[Object.keys(r.group.edges)[0]],
          "is-summarized": !0
        }, {
          default: ne((a) => [
            K(i.$slots, "default", ue(de(a)))
          ]),
          _: 2
        }, 1032, ["edges", "state"])) : ce("", !0)
      ], 64)) : (M(), L(G, { key: 1 }, [
        (M(), H(cr, {
          id: r.key,
          key: r.key,
          state: b(t)[r.key],
          "source-pos": b(o).nodes[r.edge.source],
          "target-pos": b(o).nodes[r.edge.target]
        }, null, 8, ["id", "state", "source-pos", "target-pos"])),
        e.hasEdgeOverlaySlot ? (M(), H(Sn, {
          key: r.key,
          "edge-id": r.key,
          edge: r.edge,
          state: b(t)[r.key],
          "is-summarized": !1
        }, {
          default: ne((a) => [
            K(i.$slots, "default", ue(de(a)))
          ]),
          _: 2
        }, 1032, ["edge-id", "edge", "state"])) : ce("", !0)
      ], 64))
    ], 64))), 256));
  }
}), br = { class: "v-ng-layer-edges v-ng-graph-objects" }, yr = /* @__PURE__ */ _({
  __name: "VEdgesLayer",
  setup(e) {
    const t = vt(), n = C(() => "edge-overlay" in t);
    return (o, i) => (M(), L("g", br, [
      Re(or),
      Re(mr, { "has-edge-overlay-slot": b(n) }, Bt({ _: 2 }, [
        b(n) ? {
          name: "default",
          fn: ne((s) => [
            K(o.$slots, "edge-overlay", ue(de(s)))
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["has-edge-overlay-slot"])
    ]));
  }
}), wr = /* @__PURE__ */ _({
  __name: "VEdgeLabelPlace",
  props: {
    edgeId: null,
    edge: null,
    state: null
  },
  setup(e) {
    const t = e, { scale: n } = be(), o = C(() => Hn(
      t.state.labelPosition,
      t.state.line.stroke,
      t.state.label.margin,
      t.state.label.padding,
      n.value
    ));
    return (i, s) => e.state.loop ? ce("", !0) : K(i.$slots, "default", {
      key: 0,
      edgeId: e.edgeId,
      edge: e.edge,
      config: e.state.label,
      area: b(o),
      hovered: e.state.hovered,
      selected: e.state.selected,
      scale: b(n)
    });
  }
}), Er = /* @__PURE__ */ _({
  __name: "VEdgeLabelsPlace",
  props: {
    edges: null,
    state: null,
    summarizeState: null
  },
  setup(e) {
    const t = e, { scale: n } = be(), o = C(() => {
      var i, s;
      return Hn(
        t.state.labelPosition,
        (s = (i = t.summarizeState) == null ? void 0 : i.stroke) != null ? s : t.state.line.stroke,
        t.state.label.margin,
        t.state.label.padding,
        n.value
      );
    });
    return (i, s) => e.state.loop ? ce("", !0) : K(i.$slots, "default", {
      key: 0,
      edges: e.edges,
      config: e.state.label,
      area: b(o),
      hovered: e.state.hovered,
      selected: e.state.selected,
      scale: b(n)
    });
  }
}), xr = { class: "v-ng-edge-labels" }, kr = /* @__PURE__ */ _({
  __name: "VEdgeLabels",
  props: {
    enableEdgeLabel: { type: Boolean, default: !1 },
    enableEdgesLabel: { type: Boolean, default: !1 }
  },
  setup(e) {
    const { edgeStates: t, edgeGroupStates: n, summarizedEdgeStates: o } = Se(), i = C(() => {
      const r = {}, a = {};
      return Object.entries(n.edgeGroups).forEach(([l, u]) => {
        Object.keys(u.edges).length > 0 && (u.summarize ? a[l] = u : r[l] = u);
      }), { individual: r, summarized: a };
    });
    function s(r) {
      return Object.keys(r.edges)[0];
    }
    return (r, a) => (M(), L("g", xr, [
      e.enableEdgeLabel ? (M(!0), L(G, { key: 0 }, J(b(i).individual, (l, u) => (M(), L(G, { key: u }, [
        (M(!0), L(G, null, J(l.edges, (c, d) => (M(), H(wr, {
          key: d,
          "edge-id": d,
          edge: c,
          state: b(t)[d]
        }, {
          default: ne((h) => [
            K(r.$slots, "edge-label", ue(de(h)))
          ]),
          _: 2
        }, 1032, ["edge-id", "edge", "state"]))), 128))
      ], 64))), 128)) : ce("", !0),
      e.enableEdgesLabel ? (M(!0), L(G, { key: 1 }, J(b(i).summarized, (l, u) => (M(), H(Er, {
        key: u,
        edges: l.edges,
        state: b(t)[s(l)],
        "summarize-state": b(o)[s(l)]
      }, {
        default: ne((c) => [
          K(r.$slots, "edges-label", ue(de(c)))
        ]),
        _: 2
      }, 1032, ["edges", "state", "summarize-state"]))), 128)) : ce("", !0)
    ]));
  }
}), Pr = /* @__PURE__ */ _({
  __name: "VEdgeLabelsLayer",
  props: {
    enableEdgeLabel: { type: Boolean, default: !1 },
    enableEdgesLabel: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, n) => (M(), H(kr, {
      "enable-edge-label": e.enableEdgeLabel,
      "enable-edges-label": e.enableEdgesLabel,
      class: "v-ng-layer-edge-labels v-ng-graph-objects"
    }, Bt({ _: 2 }, [
      e.enableEdgeLabel ? {
        name: "edge-label",
        fn: ne((o) => [
          K(t.$slots, "edge-label", ue(de(o)))
        ]),
        key: "0"
      } : void 0,
      e.enableEdgesLabel ? {
        name: "edges-label",
        fn: ne((o) => [
          K(t.$slots, "edges-label", ue(de(o)))
        ]),
        key: "1"
      } : void 0
    ]), 1032, ["enable-edge-label", "enable-edges-label"]));
  }
}), Sr = /* @__PURE__ */ _({
  __name: "VNodeFocusRing",
  props: {
    id: null,
    state: null,
    pos: { default: void 0 }
  },
  setup(e) {
    const t = e, n = C(() => {
      var r;
      return ((r = t.pos) == null ? void 0 : r.x) || 0;
    }), o = C(() => {
      var r;
      return ((r = t.pos) == null ? void 0 : r.y) || 0;
    }), i = mt(), s = Oe({});
    return me(() => {
      var a, l, u;
      const r = t.state.shape;
      if (r.type === "circle") {
        const c = {
          type: "circle",
          radius: r.radius + ((a = r.strokeWidth) != null ? a : 0) / 2 + i.focusring.padding + i.focusring.width / 2,
          color: "none",
          strokeWidth: i.focusring.width,
          strokeColor: i.focusring.color,
          strokeDasharray: i.focusring.dasharray
        };
        Object.assign(s, c);
      } else {
        const c = {
          type: "rect",
          width: r.width + ((l = r.strokeWidth) != null ? l : 0) + i.focusring.padding * 2 + i.focusring.width,
          height: r.height + ((u = r.strokeWidth) != null ? u : 0) + i.focusring.padding * 2 + i.focusring.width,
          borderRadius: r.borderRadius > 0 ? r.borderRadius + i.focusring.padding : 0,
          color: "none",
          strokeWidth: i.focusring.width,
          strokeColor: i.focusring.color,
          strokeDasharray: i.focusring.dasharray
        };
        Object.assign(s, c);
      }
    }), (r, a) => (M(), H(Et, {
      class: "v-ng-node-focusring",
      "base-x": b(n),
      "base-y": b(o),
      config: s
    }, null, 8, ["base-x", "base-y", "config"]));
  }
}), Mr = { class: "v-ng-layer-nodes-selections" }, Cr = /* @__PURE__ */ _({
  __name: "VFocusringLayer",
  setup(e) {
    const { nodeStates: t } = Se(), { selectedNodes: n } = xs(), o = Jt();
    return (i, s) => (M(), L("g", Mr, [
      (M(!0), L(G, null, J(b(n), (r) => (M(), H(Sr, {
        id: r,
        key: r,
        state: b(t)[r],
        pos: b(o).nodes[r]
      }, null, 8, ["id", "state", "pos"]))), 128))
    ]));
  }
}), Or = ["transform"], Mn = /* @__PURE__ */ _({
  __name: "VNode",
  props: {
    id: null,
    state: null,
    pos: { default: void 0 }
  },
  setup(e) {
    const t = e, n = C(() => {
      var d;
      return ((d = t.pos) == null ? void 0 : d.x) || 0;
    }), o = C(() => {
      var d;
      return ((d = t.pos) == null ? void 0 : d.y) || 0;
    }), { scale: i } = be(), {
      handleNodePointerDownEvent: s,
      handleNodePointerOverEvent: r,
      handleNodePointerOutEvent: a,
      handleNodeClickEvent: l,
      handleNodeDoubleClickEvent: u,
      handleNodeContextMenu: c
    } = it();
    return (d, h) => (M(), L("g", {
      class: ve({ "v-ng-node": !0, hover: e.state.hovered, selected: e.state.selected }),
      transform: `translate(${b(n)} ${b(o)})`,
      onPointerdown: h[0] || (h[0] = xe((v) => b(s)(e.id, v), ["stop"])),
      onPointerenterPassive: h[1] || (h[1] = (v) => b(r)(e.id, v)),
      onPointerleavePassive: h[2] || (h[2] = (v) => b(a)(e.id, v)),
      onClick: h[3] || (h[3] = xe((v) => b(l)(e.id, v), ["stop"])),
      onDblclick: h[4] || (h[4] = xe((v) => b(u)(e.id, v), ["stop"])),
      onContextmenu: h[5] || (h[5] = (v) => b(c)(e.id, v))
    }, [
      K(d.$slots, "override-node", {
        nodeId: e.id,
        scale: b(i),
        config: e.state.shape,
        class: ve({ draggable: e.state.draggable, selectable: e.state.selectable })
      }, () => [
        Re(Et, {
          config: e.state.shape,
          class: ve({
            "v-ng-node-default": !0,
            draggable: e.state.draggable,
            selectable: e.state.selectable
          })
        }, null, 8, ["config", "class"])
      ])
    ], 42, Or));
  }
}), zr = /* @__PURE__ */ _({
  __name: "VNodesLayer",
  setup(e) {
    const t = vt(), n = C(() => "override-node" in t), { nodeZOrderedList: o } = Se(), i = mt(), s = Jt();
    return (r, a) => b(n) ? (M(), H(Je, {
      key: 0,
      name: b(i).transition,
      css: !!b(i).transition,
      tag: "g",
      class: "v-ng-layer-nodes v-ng-graph-objects"
    }, {
      default: ne(() => [
        (M(!0), L(G, null, J(b(o), (l) => (M(), H(Mn, {
          id: l.id,
          key: l.id,
          state: l,
          pos: b(s).nodes[l.id]
        }, {
          "override-node": ne((u) => [
            K(r.$slots, "override-node", ue(de(u)))
          ]),
          _: 2
        }, 1032, ["id", "state", "pos"]))), 128))
      ]),
      _: 3
    }, 8, ["name", "css"])) : (M(), H(Je, {
      key: 1,
      name: b(i).transition,
      css: !!b(i).transition,
      tag: "g",
      class: "v-ng-layer-nodes v-ng-graph-objects"
    }, {
      default: ne(() => [
        (M(!0), L(G, null, J(b(o), (l) => (M(), H(Mn, {
          id: l.id,
          key: l.id,
          state: l,
          pos: b(s).nodes[l.id]
        }, null, 8, ["id", "state", "pos"]))), 128))
      ]),
      _: 1
    }, 8, ["name", "css"]));
  }
}), uo = {
  [N.NORTH]: 0,
  [N.NORTH_EAST]: 1,
  [N.EAST]: 2,
  [N.SOUTH_EAST]: 3,
  [N.SOUTH]: 4,
  [N.SOUTH_WEST]: 5,
  [N.WEST]: 6,
  [N.NORTH_WEST]: 7,
  [N.CENTER]: -1
}, Tr = [
  /* N */
  (e, t) => ze(e, 0, t ? 90 : 60),
  /* NE */
  (e, t) => ze(e, 45, t ? 90 : 45),
  /* E */
  (e, t) => ze(e, 90, t ? 60 : 30),
  /* SE */
  (e, t) => ze(e, 135, t ? 90 : 45),
  /* S */
  (e, t) => ze(e, 180, t ? 90 : 60),
  /* SW */
  (e, t) => ze(e, 225, t ? 90 : 45),
  /* W */
  (e, t) => ze(e, 270, t ? 60 : 30),
  /* NW */
  (e, t) => ze(e, 315, t ? 90 : 45)
];
function Ir(e, t, n, o, i) {
  if (i === N.CENTER)
    return N.CENTER;
  const s = [];
  Object.entries(n).forEach(([u, c]) => {
    let d = !1;
    if (c.nodeId === e) {
      const v = o(u);
      v && (d = !0, c = qe(se({}, c), {
        pos: { x: v.x, y: v.y }
      }));
    }
    const h = (qt(Wt(c.pos, t)) + 360 + 90) % 360;
    s.push([h, d]);
  });
  const r = $r(i), l = [
    r,
    (r + 4) % 8,
    // priority is given to diagonals
    (r + 2) % 8,
    (r - 2 + 8) % 8,
    (r + 1) % 8,
    (r - 1 + 8) % 8,
    (r + 3) % 8,
    (r - 3 + 8) % 8
  ].find((u) => s.every((c) => !Tr[u](...c)));
  return l === void 0 ? i : Lr(l, i);
}
function ze(e, t, n) {
  e %= 360;
  const o = (t - n + 360) % 360, i = (t + n) % 360;
  return o <= i ? o < e && e < i : o < e || e < i;
}
function $r(e) {
  var t;
  return (t = uo[e]) != null ? t : 0;
}
function Lr(e, t) {
  var n, o;
  return (o = (n = Object.entries(uo)[e]) == null ? void 0 : n[0]) != null ? o : t;
}
const Ar = ["transform"], Cn = /* @__PURE__ */ _({
  __name: "VNodeLabel",
  props: {
    id: null,
    state: null,
    pos: { default: void 0 }
  },
  setup(e) {
    const t = e, n = mt(), { edgeStates: o } = Se(), { scale: i } = be(), {
      handleNodePointerDownEvent: s,
      handleNodePointerOverEvent: r,
      handleNodePointerOutEvent: a,
      handleNodeClickEvent: l,
      handleNodeDoubleClickEvent: u,
      handleNodeContextMenu: c
    } = it(), d = C(() => {
      var z;
      return ((z = t.pos) == null ? void 0 : z.x) || 0;
    }), h = C(() => {
      var z;
      return ((z = t.pos) == null ? void 0 : z.y) || 0;
    }), v = C(() => t.state.label.direction === N.CENTER ? 0 : t.state.label.margin * i.value), E = j(0), x = j(0), w = j(0), g = j(0), y = C(() => {
      var R;
      const z = t.state.label.direction, T = t.state.label.directionAutoAdjustment;
      if (T === !1)
        return z;
      const A = { x: d.value, y: h.value };
      return T === !0 ? Ir(
        t.state.id,
        A,
        t.state.oppositeNodes,
        (Y) => {
          var B, F;
          return (F = (B = o[Y]) == null ? void 0 : B.loop) == null ? void 0 : F.center;
        },
        z
      ) : (R = T({
        nodeId: t.state.id,
        pos: A,
        oppositeNodes: t.state.oppositeNodes
      })) != null ? R : z;
    }), k = C(() => {
      switch (y.value) {
        case N.CENTER:
        case N.NORTH:
        case N.SOUTH:
          return "middle";
        case N.EAST:
        case N.NORTH_EAST:
        case N.SOUTH_EAST:
          return "start";
        case N.WEST:
        case N.NORTH_WEST:
        case N.SOUTH_WEST:
        default:
          return "end";
      }
    }), m = C(() => {
      switch (y.value) {
        case N.NORTH:
        case N.NORTH_EAST:
        case N.NORTH_WEST:
          return "text-top";
        case N.SOUTH:
        case N.SOUTH_EAST:
        case N.SOUTH_WEST:
          return "hanging";
        case N.CENTER:
        case N.EAST:
        case N.WEST:
        default:
          return "central";
      }
    }), f = C(() => {
      switch (y.value) {
        case N.CENTER:
        case N.NORTH:
        case N.SOUTH:
          return 0;
        case N.EAST:
          return x.value;
        case N.WEST:
          return -x.value;
        case N.NORTH_EAST:
        case N.SOUTH_EAST:
          return g.value;
        case N.NORTH_WEST:
        case N.SOUTH_WEST:
        default:
          return -g.value;
      }
    }), p = C(() => {
      switch (y.value) {
        case N.NORTH:
          return -E.value;
        case N.SOUTH:
          return E.value;
        case N.CENTER:
        case N.EAST:
        case N.WEST:
          return 0;
        case N.NORTH_EAST:
        case N.NORTH_WEST:
          return -w.value;
        case N.SOUTH_EAST:
        case N.SOUTH_WEST:
        default:
          return w.value;
      }
    });
    me(() => {
      const z = i.value, T = t.state.shape;
      if (T.type == "circle") {
        const A = T.radius * z, R = A + v.value, Y = Math.sqrt(ae(R, 2) / 2);
        E.value = A + v.value, x.value = A + v.value, w.value = Y, g.value = Y;
      } else {
        const A = T.borderRadius * z, R = T.width * z, Y = T.height * z, B = A + v.value, F = Math.sqrt(ae(B, 2) / 2);
        E.value = Y / 2 + v.value, x.value = R / 2 + v.value, w.value = Y / 2 - A + F, g.value = R / 2 - A + F;
      }
    });
    const S = C(() => (z) => n.label.handleNodeEvents ? {
      pointerdown: (T) => {
        T.stopPropagation(), s(z, T);
      },
      pointerenter: (T) => r(z, T),
      pointerleave: (T) => a(z, T),
      click: (T) => {
        T.stopPropagation(), l(z, T);
      },
      dblclick: (T) => {
        T.stopPropagation(), u(z, T);
      },
      contextmenu: (T) => {
        c(z, T);
      }
    } : {}), O = C(() => {
      const z = n.label.handleNodeEvents;
      return {
        "v-ng-node-label": !0,
        hover: z && t.state.hovered,
        selected: z && t.state.selected
      };
    }), I = C(() => {
      const z = n.label.handleNodeEvents;
      return {
        draggable: z && t.state.draggable,
        selectable: z && t.state.selectable
      };
    });
    return (z, T) => (M(), L("g", Pe({
      class: b(O),
      transform: `translate(${b(d)} ${b(h)})`
    }, Vo(b(S)(e.id), !0)), [
      K(z.$slots, "override-node-label", {
        nodeId: e.id,
        scale: b(i),
        text: e.state.labelText,
        x: b(f),
        y: b(p),
        config: e.state.label,
        shape: e.state.shape,
        textAnchor: b(k),
        dominantBaseline: b(m),
        class: ve(b(I))
      }, () => [
        Re(xt, {
          text: e.state.labelText,
          x: 0,
          y: 0,
          config: e.state.label,
          "text-anchor": b(k),
          "dominant-baseline": b(m),
          class: ve(b(I)),
          transform: `translate(${b(f)} ${b(p)})`
        }, null, 8, ["text", "config", "text-anchor", "dominant-baseline", "class", "transform"])
      ])
    ], 16, Ar));
  }
}), Zr = /* @__PURE__ */ _({
  __name: "VNodeLabelsLayer",
  setup(e) {
    const t = vt(), n = C(() => "override-node-label" in t), { nodeZOrderedList: o } = Se(), i = mt(), s = Jt(), r = C(() => a(o.value));
    function a(l) {
      return l.filter((u) => {
        var c;
        return u.label.visible && ((c = u.labelText) != null ? c : !1);
      });
    }
    return (l, u) => b(n) ? (M(), H(Je, {
      key: 0,
      name: b(i).transition,
      css: !!b(i).transition,
      tag: "g",
      class: "v-ng-layer-node-labels v-ng-graph-objects"
    }, {
      default: ne(() => [
        (M(!0), L(G, null, J(b(r), (c) => (M(), H(Cn, {
          id: c.id,
          key: c.id,
          state: c,
          pos: b(s).nodes[c.id]
        }, {
          "override-node-label": ne((d) => [
            K(l.$slots, "override-node-label", ue(de(d)))
          ]),
          _: 2
        }, 1032, ["id", "state", "pos"]))), 128))
      ]),
      _: 3
    }, 8, ["name", "css"])) : (M(), H(Je, {
      key: 1,
      name: b(i).transition,
      css: !!b(i).transition,
      tag: "g",
      class: "v-ng-layer-node-labels v-ng-graph-objects"
    }, {
      default: ne(() => [
        (M(!0), L(G, null, J(b(r), (c) => (M(), H(Cn, {
          id: c.id,
          key: c.id,
          state: c,
          pos: b(s).nodes[c.id]
        }, null, 8, ["id", "state", "pos"]))), 128))
      ]),
      _: 1
    }, 8, ["name", "css"]));
  }
}), Dr = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin"], Nr = /* @__PURE__ */ _({
  __name: "VPath",
  props: {
    path: null
  },
  setup(e) {
    const t = e, { nodeStates: n, edgeStates: o, layouts: i } = Se(), { scale: s } = be(), r = Zn();
    function a(h) {
      if (h.edges.length === 0) return [];
      const v = $.value(r.margin, h.path) * s.value;
      return pi(
        h,
        n,
        i.nodes,
        o,
        s.value,
        r.curveInNode,
        r.end,
        v
      );
    }
    function l(h) {
      const v = a(h);
      let E = !0;
      return v.map((x) => {
        if (x === null)
          E = !0;
        else {
          if (typeof x == "string")
            return x;
          if (x instanceof Array) {
            x = [...x];
            const w = [];
            if (x.length % 2 === 1) {
              const g = x[0];
              x = x.slice(1), w.push(`L ${g.x} ${g.y}`);
            }
            return Rt(x, 2).map(([g, y]) => w.push(`Q ${g.x} ${g.y} ${y.x} ${y.y}`)), w.join(" ");
          } else {
            const w = E;
            return E = !1, `${w ? "M " : "L "}${x.x} ${x.y}`;
          }
        }
      }).join(" ");
    }
    const u = C(() => {
      const h = t.path;
      return h.selected ? $.values(r.selected, h.path) : h.hovered && r.hover ? $.values(r.hover, h.path) : $.values(r.normal, h.path);
    }), c = C(() => ot(u.value.dasharray, s.value)), d = C(() => {
      const h = u.value.animate ? gt(u.value.dasharray) * u.value.animationSpeed * s.value : !1;
      return h ? { "--animation-speed": h } : void 0;
    });
    return (h, v) => (M(), L("path", {
      class: ve({
        "v-ng-path": !0,
        animate: b(u).animate,
        clickable: e.path.clickable,
        hoverable: e.path.hoverable
      }),
      d: l(e.path),
      fill: "none",
      stroke: b(u).color,
      "stroke-width": b(u).width * b(s),
      "stroke-dasharray": b(c),
      "stroke-linecap": b(u).linecap,
      "stroke-linejoin": b(u).linejoin,
      style: nt(b(d))
    }, null, 14, Dr));
  }
}), jr = /* @__PURE__ */ _({
  __name: "VPaths",
  setup(e) {
    const { pathZOrderedList: t } = Se(), n = Zn(), {
      handlePathPointerDownEvent: o,
      handlePathPointerOverEvent: i,
      handlePathPointerOutEvent: s,
      handlePathClickEvent: r,
      handlePathDoubleClickEvent: a,
      handlePathContextMenu: l
    } = it();
    return (u, c) => (M(), H(Je, {
      name: b(n).transition,
      css: !!b(n).transition,
      tag: "g",
      class: "v-ng-paths v-ng-layer-paths v-ng-graph-objects"
    }, {
      default: ne(() => [
        (M(!0), L(G, null, J(b(t), (d) => (M(), H(Nr, {
          key: d.id,
          path: d,
          onPointerdown: (h) => b(o)(d.id, h),
          onPointerenterPassive: (h) => b(i)(d.id, h),
          onPointerleavePassive: (h) => b(s)(d.id, h),
          onClick: xe((h) => b(r)(d.id, h), ["stop"]),
          onDblclick: xe((h) => b(a)(d.id, h), ["stop"]),
          onContextmenu: (h) => b(l)(d.id, h)
        }, null, 8, ["path", "onPointerdown", "onPointerenterPassive", "onPointerleavePassive", "onClick", "onDblclick", "onContextmenu"]))), 128))
      ]),
      _: 1
    }, 8, ["name", "css"]));
  }
}), Br = /* @__PURE__ */ _({
  __name: "VPathsLayer",
  setup(e) {
    return (t, n) => (M(), H(jr));
  }
}), Rr = { key: 0 }, Vr = /* @__PURE__ */ _({
  __name: "VNetworkGraph",
  props: {
    nodes: { default: () => ({}) },
    edges: { default: () => ({}) },
    paths: { default: () => ({}) },
    layouts: { default: () => ({}) },
    zoomLevel: { default: 1 },
    selectedNodes: { default: () => [] },
    selectedEdges: { default: () => [] },
    selectedPaths: { default: () => [] },
    configs: { default: () => ({}) },
    layers: { default: () => ({}) },
    eventHandlers: { default: () => ({}) }
  },
  emits: ["update:zoomLevel", "update:selectedNodes", "update:selectedEdges", "update:selectedPaths", "update:layouts"],
  setup(e, { expose: t, emit: n }) {
    const o = e, i = [
      "override-node",
      "override-node-label",
      "edge-overlay",
      "edge-label",
      "edges-label"
    ], s = vt(), r = Ce(o, "nodes"), a = Ce(o, "edges"), { objects: l, isInCompatibilityModeForPath: u } = ys(
      Ce(o, "paths")
    ), c = Ji();
    Object.entries(o.eventHandlers).forEach(([P, D]) => {
      c.on(P, D);
    });
    const d = Ko(Ce(o, "configs")), h = C(() => {
      const P = new Set(Object.keys(s));
      i.forEach((Z) => P.delete(Z));
      const D = Object.fromEntries(Uo.map((Z) => [Z, []]));
      return Object.assign(
        D,
        Object.entries(o.layers).reduce(
          (Z, [W, te]) => (P.delete(W), te in Z ? Z[te].push(W) : Z[te] = [W], Z),
          {}
        )
      ), D.root.push(...P), D;
    }), v = C(() => d.view.grid.visible), E = C(() => {
      const P = h.value;
      return v.value || P.background.length > 0 || P.grid.length > 0;
    }), x = Ms(d, s), w = j(), g = j(), y = j(), k = j(
      0
      /* INITIAL */
    ), m = C(
      () => k.value !== 0
      /* INITIAL */
    ), f = ws(o, "zoomLevel", n, (P) => (P = Math.max(P, d.view.minZoomLevel), P = Math.min(P, d.view.maxZoomLevel), P)), { svgPanZoom: p, onSvgPanZoomMounted: S, onSvgPanZoomUnmounted: O } = gs(g, {
      viewportSelector: ".v-ng-viewport",
      minZoom: d.view.minZoomLevel,
      // temporary
      maxZoom: d.view.maxZoomLevel,
      // temporary
      dblClickZoomEnabled: sn(d.view),
      mouseWheelZoomEnabled: St(d.view),
      fit: d.view.autoPanAndZoomOnLoad === "fit-content",
      center: d.view.autoPanAndZoomOnLoad !== !1,
      zoomEnabled: d.view.zoomEnabled,
      preventMouseEventsDefault: !1,
      onZoom: (P) => {
        var Z, W;
        if (k.value === 2) return;
        const D = (W = (Z = p.value) == null ? void 0 : Z.getRealZoom()) != null ? W : 1;
        Math.abs(f.value - D) >= 1e-6 && (f.value = D, c.emit("view:zoom", D));
      },
      panEnabled: d.view.panEnabled,
      onPan: (P) => {
        k.value !== 2 && c.emit("view:pan", P);
      }
    });
    Xo({ container: w, svg: g, viewport: y, svgPanZoom: p });
    const I = { width: 0, height: 0 }, z = globalThis.ResizeObserver ? new ResizeObserver(() => {
      var D, Z, W;
      if ((D = p.value) == null || D.resize(), !d.view.autoPanOnResize) return;
      const P = (Z = w.value) == null ? void 0 : Z.getBoundingClientRect();
      if (P) {
        const te = -(I.width - P.width) / 2, je = -(I.height - P.height) / 2;
        (W = p.value) == null || W.panBy({ x: te, y: je });
        const { width: Me, height: Mt } = P;
        (I.width !== Me || I.height !== Mt) && (Object.assign(I, { width: Me, height: Mt }), c.emit("view:resize", { x: P.x, y: P.y, width: Me, height: Mt }));
      }
    }) : void 0;
    S(() => {
      var te, je, Me;
      const P = q(w.value, "svg-pan-zoom container");
      z == null || z.observe(P), (je = (te = d.view).onSvgPanZoomInitialized) == null || je.call(te, q(p.value, "svg-pan-zoom instance"));
      const D = P.getBoundingClientRect(), { width: Z, height: W } = D;
      Object.assign(I, { width: Z, height: W }), (Me = y.value) == null || Me.addEventListener("touchstart", rn, { passive: !1 });
    }), O(() => {
      var P;
      z == null || z.disconnect(), (P = y.value) == null || P.removeEventListener("touchstart", rn);
    });
    const T = (P) => {
      var D;
      (D = p.value) == null || D.applyAbsoluteZoomLevel(
        P,
        d.view.minZoomLevel,
        d.view.maxZoomLevel
      );
    };
    U(
      () => d.view.panEnabled,
      (P) => {
        var D;
        (D = p.value) == null || D.setPanEnabled(P);
      }
    ), U(
      () => [
        d.view.zoomEnabled,
        sn(d.view),
        St(d.view)
      ],
      () => {
        const P = p.value;
        P && $o(
          P,
          d.view.zoomEnabled,
          d.view.doubleClickZoomEnabled,
          d.view.mouseWheelZoomEnabled
        );
      }
    ), U(f, (P) => T(P)), U(
      () => [d.view.minZoomLevel, d.view.maxZoomLevel],
      (P) => {
        T(f.value);
      }
    );
    const { scale: A } = ps(f, d.view);
    S(() => {
      const P = o.zoomLevel;
      T(P);
    });
    const R = () => Ee(this, null, function* () {
      var P;
      Object.keys(o.nodes).length > 0 && ((P = p.value) == null || P.updateBBox(), yield Pn());
    }), Y = (P) => Ee(this, null, function* () {
      var je, Me;
      const D = !P || P.margin === void 0 ? d.view.fitContentMargin : P.margin;
      yield R();
      const Z = q(g.value).getBoundingClientRect(), W = Ls(D, Z), te = As(
        q(y.value),
        Z,
        ge.nodes,
        f.value,
        W,
        d.view.scalingObjects
      );
      te ? (T(te.zoom), (je = p.value) == null || je.pan(te.pos)) : (Me = p.value) == null || Me.center(), c.emit("view:fit", void 0);
    }), B = () => Ee(this, null, function* () {
      var P;
      yield R(), (P = p.value) == null || P.center();
    }), F = () => {
      var P, D;
      return (D = (P = p.value) == null ? void 0 : P.getViewBox()) != null ? D : {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
    }, ye = (P) => {
      var D;
      return (D = p.value) == null ? void 0 : D.setViewBox(P);
    }, ie = It(o, "selectedNodes", r, n);
    U(ie, (P) => c.emit("node:select", Array.from(P)));
    const ke = It(o, "selectedEdges", a, n);
    U(ke, (P) => c.emit("edge:select", Array.from(P)));
    const Ne = It(o, "selectedPaths", l, n);
    U(Ne, (P) => c.emit("path:select", Array.from(P))), Es(ie, ke, Ne);
    const Xe = Ie(/* @__PURE__ */ new Set()), le = Ie(/* @__PURE__ */ new Set()), Ve = Ie(/* @__PURE__ */ new Set()), ge = Ie({ nodes: {} });
    ks(ge), U(
      () => o.layouts,
      () => {
        var P;
        return Object.assign(ge.nodes, (P = o.layouts.nodes) != null ? P : {});
      },
      { deep: !0, immediate: !0 }
    ), U(ge, () => n("update:layouts", ge), { deep: !0 });
    const kt = xi(), Pt = j(!1);
    c.on("node:dragstart", (P) => Pt.value = !0), c.on("node:dragend", (P) => Pt.value = !1), c.on("view:mode", (P) => {
      var D, Z, W, te;
      d.view.panEnabled && (P === "default" ? (D = p.value) == null || D.enablePan() : (Z = p.value) == null || Z.disablePan()), d.view.zoomEnabled && (P === "default" ? (W = p.value) == null || W.enableZoom() : (te = p.value) == null || te.disableZoom());
    });
    const fo = C(() => d.view.panEnabled || d.view.zoomEnabled || d.node.draggable), { nodeStates: ho, edgeStates: vo, pathStates: go } = Ci(
      zt(r, ie, Xe),
      zt(a, ke, le),
      zt(l, Ne, Ve),
      Ge(d),
      ge,
      o.layouts,
      kt,
      A
    ), po = C(() => St(d.view)), { isBoxSelectionMode: mo, selectionBox: en, startBoxSelection: bo, stopBoxSelection: yo } = Yi(
      g,
      Ge(ge),
      Ge(f),
      ho,
      vo,
      go,
      ie,
      ke,
      Ne,
      Xe,
      le,
      Ve,
      u,
      po,
      d,
      c
    ), tn = () => ({
      layouts: Ie(ge.nodes),
      // deprecated parameter.
      nodePositions: Ce(ge, "nodes"),
      nodes: r,
      edges: a,
      configs: Ge(d),
      scale: Ge(A),
      emitter: c,
      svgPanZoom: q(p.value)
    });
    U(
      () => d.view.layoutHandler,
      (P, D) => {
        D.deactivate(), P.activate(tn());
      }
    );
    const { transitionWhile: wo, transitionOption: nn } = bs(), Eo = C(() => {
      const P = nn.value;
      return P.enabled ? {
        "--transition-duration": P.duration + "ms",
        "--transition-function": P.timingFunction
      } : {};
    });
    S(() => Ee(this, null, function* () {
      if (d.view.onBeforeInitialDisplay) {
        const Z = d.view.onBeforeInitialDisplay();
        ei(Z) && (yield Z);
      }
      const P = q(p.value, "svg-pan-zoom");
      d.view.layoutHandler.activate(tn()), yield Pn();
      const D = d.view.autoPanAndZoomOnLoad;
      if (d.view.fit || D !== !1) {
        const Z = Object.keys(o.nodes).length == 0, W = P.getPan();
        if (Z || D === "center-zero") {
          yield R();
          const te = P.getSizes();
          P.pan({
            x: te.width / 2,
            y: te.height / 2
          });
        } else D === "fit-content" || d.view.fit ? yield Y() : D === "center-content" ? yield B() : yield R();
        jt(() => {
          const te = P.getPan();
          W.x === te.x && W.y === te.y && c.emit("view:pan", te);
        });
      } else
        yield R();
      c.emit("view:load"), k.value = 1;
    })), O(() => {
      k.value = 2, c.emit("view:unload"), d.view.layoutHandler.deactivate();
    });
    function xo() {
      var P;
      (P = p.value) == null || P.zoomIn();
    }
    function ko() {
      var P;
      (P = p.value) == null || P.zoomOut();
    }
    function Po(P) {
      var D;
      (D = p.value) == null || D.pan(P);
    }
    function So(P) {
      var D;
      (D = p.value) == null || D.panBy(P);
    }
    function Mo() {
      return q(p.value).getPan();
    }
    function Co() {
      const P = q(p.value).getSizes();
      return {
        width: P.width,
        height: P.height,
        viewBox: P.viewBox
      };
    }
    function Oo(P) {
      return Dt(
        q(g.value, "svg"),
        q(y.value, "viewport"),
        P
      );
    }
    function zo(P) {
      return _i(
        q(g.value, "svg"),
        q(y.value, "viewport"),
        P
      );
    }
    function To() {
      return Gn(
        q(g.value, "svg"),
        q(y.value, "viewport"),
        A.value
      ).outerHTML;
    }
    function Io() {
      return Ee(this, arguments, function* (P = {}) {
        return (yield on(P)).outerHTML;
      });
    }
    function on() {
      return Ee(this, arguments, function* (P = {}) {
        return Ui(
          q(g.value, "svg"),
          q(y.value, "viewport"),
          A.value,
          P
        );
      });
    }
    t({
      // methods
      fitToContents: Y,
      panToCenter: B,
      getViewBox: F,
      setViewBox: ye,
      transitionWhile: wo,
      startBoxSelection: bo,
      stopBoxSelection: yo,
      zoomIn: xo,
      zoomOut: ko,
      panTo: Po,
      panBy: So,
      getPan: Mo,
      getSizes: Co,
      translateFromDomToSvgCoordinates: Oo,
      translateFromSvgToDomCoordinates: zo,
      getAsSvg: To,
      exportAsSvgText: Io,
      exportAsSvgElement: on
    });
    function $o(P, D, Z, W) {
      P.setZoomEnabled(D), D && Z ? P.enableDblClickZoom() : P.disableDblClickZoom(), D && W ? P.enableMouseWheelZoom() : P.disableMouseWheelZoom();
    }
    function sn(P) {
      return P.zoomEnabled && P.doubleClickZoomEnabled;
    }
    function St(P) {
      return P.zoomEnabled && P.mouseWheelZoomEnabled;
    }
    function rn(P) {
      P.stopPropagation();
    }
    return (P, D) => (M(), L("div", {
      ref_key: "container",
      ref: w,
      class: "v-network-graph v-ng-container"
    }, [
      (M(), L("svg", {
        ref_key: "svg",
        ref: g,
        class: ve(["v-ng-canvas", { show: b(m), dragging: Pt.value, touches: b(fo), "box-selection-mode": b(mo) }]),
        width: "100%",
        height: "100%"
      }, [
        (M(!0), L(G, null, J(b(h).root, (Z) => K(P.$slots, Z, {
          key: Z,
          scale: b(A)
        })), 128)),
        Object.keys(b(kt).markers).length > 0 ? (M(), L("defs", Rr, [
          (M(!0), L(G, null, J(b(kt).markers, (Z, W) => (M(), H(Xs, {
            id: W,
            key: W,
            marker: Z,
            scale: b(A)
          }, null, 8, ["id", "marker", "scale"]))), 128))
        ])) : ce("", !0),
        b(E) ? (M(), H(er, { key: 1 }, {
          default: ne(() => [
            (M(!0), L(G, null, J(b(h).background, (Z) => (M(), L("g", {
              key: Z,
              class: "v-ng-layer"
            }, [
              K(P.$slots, Z, { scale: b(A) })
            ]))), 128)),
            b(v) ? (M(), H(Js, { key: 0 })) : ce("", !0),
            (M(!0), L(G, null, J(b(h).grid, (Z) => (M(), L("g", {
              key: Z,
              class: "v-ng-layer"
            }, [
              K(P.$slots, Z, { scale: b(A) })
            ]))), 128))
          ]),
          _: 3
        })) : ce("", !0),
        zn("g", {
          ref_key: "viewport",
          ref: y,
          class: ve(["v-ng-viewport", { "v-ng-transition": b(nn).enabled }]),
          style: nt(b(Eo))
        }, [
          (M(!0), L(G, null, J(b(h).base, (Z) => (M(), L("g", {
            key: Z,
            class: "v-ng-layer"
          }, [
            K(P.$slots, Z, { scale: b(A) })
          ]))), 128)),
          (M(!0), L(G, null, J(b(x), (Z) => (M(), L(G, { key: Z }, [
            Z === "edges" ? (M(), H(yr, { key: 0 }, Bt({ _: 2 }, [
              "edge-overlay" in b(s) ? {
                name: "edge-overlay",
                fn: ne((W) => [
                  K(P.$slots, "edge-overlay", ue(de(W)))
                ]),
                key: "0"
              } : void 0
            ]), 1024)) : Z === "edge-labels" ? (M(), H(Pr, {
              key: 1,
              "enable-edge-label": "edge-label" in b(s),
              "enable-edges-label": "edges-label" in b(s)
            }, {
              "edge-label": ne((W) => [
                K(P.$slots, "edge-label", ue(de(W)))
              ]),
              "edges-label": ne((W) => [
                K(P.$slots, "edges-label", ue(de(W)))
              ]),
              _: 3
            }, 8, ["enable-edge-label", "enable-edges-label"])) : Z === "focusring" ? (M(), H(Cr, { key: 2 })) : Z === "nodes" ? (M(), H(zr, { key: 3 }, {
              "override-node": ne((W) => [
                K(P.$slots, "override-node", ue(de(W)))
              ]),
              _: 3
            })) : Z === "node-labels" ? (M(), H(Zr, { key: 4 }, {
              "override-node-label": ne((W) => [
                K(P.$slots, "override-node-label", ue(de(W)))
              ]),
              _: 3
            })) : Z === "paths" ? (M(), H(Br, { key: 5 })) : ce("", !0),
            (M(!0), L(G, null, J(b(h)[Z], (W) => (M(), L("g", {
              key: W,
              class: "v-ng-layer"
            }, [
              K(P.$slots, W, { scale: b(A) })
            ]))), 128))
          ], 64))), 128))
        ], 6),
        b(en) ? (M(), H(Bs, {
          key: 2,
          box: b(en),
          config: b(d).view.selection.box
        }, null, 8, ["box", "config"])) : ce("", !0)
      ], 2))
    ], 512));
  }
}), Wr = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [o, i] of t)
    n[o] = i;
  return n;
}, Hr = {};
function _r(e, t) {
  return M(), L("defs", null, [
    (M(), H(On("style"), null, {
      default: ne(() => [
        K(e.$slots, "default")
      ]),
      _: 3
    }))
  ]);
}
const Fr = /* @__PURE__ */ Wr(Hr, [["render", _r]]), Ur = /* @__PURE__ */ _({
  __name: "VEdgeLabel",
  props: {
    area: null,
    config: null,
    text: { default: "" },
    align: { default: "center" },
    verticalAlign: { default: "center" },
    edge: { default: void 0 },
    hovered: { type: Boolean, default: void 0 },
    selected: { type: Boolean, default: void 0 },
    scale: { default: void 0 }
  },
  setup(e) {
    const t = e, n = j(0), o = j(0), i = j("middle"), s = j("central"), r = j(0);
    me(() => {
      const l = t.area.source, u = t.area.target;
      t.align === "source" ? (l.above.x == u.above.x ? i.value = l.above.y > u.above.y ? "start" : "end" : i.value = l.above.x < u.above.x ? "start" : "end", t.verticalAlign === "above" ? (n.value = l.above.x, o.value = l.above.y, s.value = "text-top") : t.verticalAlign === "below" ? (n.value = l.below.x, o.value = l.below.y, s.value = "hanging") : (n.value = (l.above.x + l.below.x) / 2, o.value = (l.above.y + l.below.y) / 2, s.value = "central")) : t.align === "target" ? (l.above.x == u.above.x ? i.value = l.above.y < u.above.y ? "start" : "end" : i.value = l.above.x > u.above.x ? "start" : "end", t.verticalAlign === "above" ? (n.value = u.above.x, o.value = u.above.y, s.value = "text-top") : t.verticalAlign === "below" ? (n.value = u.below.x, o.value = u.below.y, s.value = "hanging") : (n.value = (u.above.x + u.below.x) / 2, o.value = (u.above.y + u.below.y) / 2, s.value = "central")) : (i.value = "middle", t.verticalAlign === "above" ? (n.value = (l.above.x + u.above.x) / 2, o.value = (l.above.y + u.above.y) / 2, s.value = "text-top") : t.verticalAlign === "below" ? (n.value = (l.below.x + u.below.x) / 2, o.value = (l.below.y + u.below.y) / 2, s.value = "hanging") : (n.value = (l.above.x + u.below.x) / 2, o.value = (l.above.y + u.below.y) / 2, s.value = "central"));
      let c = Q.fromPositions(l.above, u.above).v.angleDegree();
      (c < -90 || c >= 90) && (c = c + 180, c > 180 && (c -= 360)), r.value = c;
    });
    const a = C(() => s.value === "central" && !t.config.background ? qe(se({}, t.config), {
      background: {
        visible: !0,
        color: "#ffffff",
        padding: {
          vertical: 1,
          horizontal: 4
        },
        borderRadius: 2
      }
    }) : t.config);
    return (l, u) => (M(), H(xt, {
      class: "v-ng-edge-label",
      text: e.text,
      x: n.value,
      y: o.value,
      config: b(a),
      "text-anchor": i.value,
      "dominant-baseline": s.value,
      transform: `rotate(${r.value} ${n.value} ${o.value})`
    }, null, 8, ["text", "x", "y", "config", "text-anchor", "dominant-baseline", "transform"]));
  }
}), Xr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VEdgeLabel: Ur,
  VLabelText: xt,
  VNetworkGraph: Vr,
  VShape: Et,
  VStyle: Fr
}, Symbol.toStringTag, { value: "Module" })), qr = 10;
class ta extends $n {
  constructor(t = {}) {
    super(), this.options = t;
  }
  setNodePosition(t, n) {
    const o = this.options.grid || qr;
    t.value.x = Math.floor(n.x / o) * o, t.value.y = Math.floor(n.y / o) * o;
  }
}
const na = function(e) {
  Object.entries(Xr).forEach(([t, n]) => {
    e.component(t, n);
  });
};
export {
  $ as Config,
  ta as GridLayout,
  Uo as LayerPositions,
  N as NodeLabelDirection,
  $n as SimpleLayout,
  Ur as VEdgeLabel,
  xt as VLabelText,
  Vr as VNetworkGraph,
  Et as VShape,
  Fr as VStyle,
  V as Vector2D,
  Qr as configsWithType,
  na as default,
  Jr as defineConfigs,
  ea as getFullConfigs,
  Se as useStates,
  Ct as withSelf
};
//# sourceMappingURL=index.js.map
